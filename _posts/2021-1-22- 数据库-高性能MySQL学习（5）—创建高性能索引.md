---
title: 高性能MySQL学习（5）—创建高性能索引
date: 2021-1-22 23:29:53
categories:
- 数据库
tags:
- 数据库
---

![]({{ site.url }}/assets/img/数据库/5.0.png)

## 1、索引基础

### 1.1、什么是索引？

​      索引（在MySQL中也叫做“键（key）”）是**存储引擎用于快速找到记录的一种数据结构**。索引对于良好的性能非常关键。尤其是当表中的数据量越来越大时，索引对性能的影响愈发重要。在数据量较小且负载较低时，不恰当的索引对性能的影响可能还不明显，但当数据量逐渐增大时，性能则会急剧下降。 

### 1.2、索引的优缺点

- 优点：

> 1、索引大大减少了服务器需要扫描的数据量
>
> 2、索引可以帮助服务器避免排序和临时表
>
> 3、索引可以将随机I/O变成顺序I/O

- 缺点：

> 1、创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加
>
> 2、索引也需要占空间，如果我们有大量的索引，索引文件可能会比数据文件更快达到上线值
>
> 3、当对表中的数据进行增加、删除、修改时，索引也需要动态的维护，降低了数据的维护速度。

### 1.3、索引的类型？

​      索引有很多种类型，可以为不同的场景提供更好的性能。在MySQL中，**索引是在存储引擎层而不是服务器层实现的**。所以，并没有统一的索引标准：**不同存储引擎的索引的工作方式并不一样**，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。 

#### 1.3.1、B-Tree索引

**B-Tree索引适用于全键值、键值范围或键值前缀查找**。其中**键前缀查找只适用于根据最左前缀的查找**。前面所述的索引对如下类型的查询有效。

举例：创建一个（a,b）的联合索引，那么它的索引树就是下图的样子。

![]({{ site.url }}/assets/img/数据库/5.1.png)

   可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。但是我们又可发现a在等值的情况下，b值又是按顺序排列的，但是这种顺序是相对的。这是因为MySQL创建联合索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序。所以b=2这种查询条件没有办法利用索引。 

 由于整个过程是基于explain结果分析的，那接下来在了解下explain中的**type**字段和**key_lef**字段。 

| **type**  | **联接类型。下面给出各种联接类型,按照从最佳类型到最坏类型进行排序:（重点看ref,rang,index）** |
| --------- | ------------------------------------------------------------ |
| system    | 表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，可以忽略不计 |
| const     | 表示通过索引一次就找到了，const用于比较primary key 或者 unique索引。因为只需匹配一行数据，所有很快。如果将主键置于where列表中，mysql就能将该查询转换为一个const |
| eq_ref    | 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键 或 唯一索引扫描。 |
| **ref**   | 非唯一性索引扫描，返回匹配某个单独值的所有行。本质是也是一种索引访问，它返回所有匹配某个单独值的行，然而他可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体。 |
| **range** | 只检索给定范围的行，使用一个索引来选择行。key列显示使用了那个索引。一般就是在where语句中出现了bettween、<、>、in等的查询。这种索引列上的范围扫描比全索引扫描要好。只需要开始于某个点，结束于另一个点，不用扫描全部索引。 |
| **index** | index与ALL区别为index类型只遍历索引树。这通常为ALL块，应为索引文件通常比数据文件小。（Index与ALL虽然都是读全表，但index是从索引中读取，而ALL是从硬盘读取） |
| ALL       | 遍历全表以找到匹配的行                                       |

| **key_len**        | **显示MySQL实际决定使用的索引的长度。如果索引是NULL，则长度为NULL。如果不是NULL，则为使用的索引的长度。所以通过此字段就可推断出使用了那个索引。** |
| ------------------ | ------------------------------------------------------------ |
| 定长字段           | int占用4个字节，date占用3个字节，char(n)占用n个字符。        |
| 变长字段varchar(n) | 则占用n个字符+两个字节。                                     |
| 不同的字符集       | 一个字符占用的字节数是不同的。Latin1编码的，一个字符占用一个字节，gdk编码的，一个字符占用两个字节，utf-8编码的，一个字符占用三个字节。 |

 首先创建一个表 ：

![]({{ site.url }}/assets/img/数据库/5.2.png)

 该表中对id列.name列.age列建立了一个联合索引 id_name_age_index，实际上相当于建立了三个索引（id）（id_name）（id_name_age）。 

下面介绍下可能会使用到该索引的几种情况：

**1.全值匹配查询时**

![]({{ site.url }}/assets/img/数据库/5.7.png)

![]({{ site.url }}/assets/img/数据库/5.8.png)

![]({{ site.url }}/assets/img/数据库/5.9.png)

​    通过观察上面的结果图可知，where后面的查询条件，不论是使用（id，age，name）（name，id，age）还是（age，name，id）顺序，在查询时都使用到了联合索引，可能有同学会疑惑，为什么底下两个的搜索条件明明没有按照联合索引从左到右进行匹配，却也使用到了联合索引？ 这是因为MySQL中有查询优化器explain，所以**sql语句中字段的顺序不需要和联合索引定义的字段顺序相同，查询优化器会判断纠正这条SQL语句以什么样的顺序执行效率高，最后才能生成真正的执行计划，所以不论以何种顺序都可使用到联合索引。**

**2.匹配最左边的列时**

![img]({{ site.url }}/assets/img/数据库/5.10.png)

　　该搜索是遵循最左匹配原则的，通过key字段也可知，在搜索过程中使用到了联合索引，且使用的是联合索引中的（id）索引，因为key_len字段值为5，而id索引的长度正好为5（因为id为int型，允许null，所以占5个字节）。

![img]({{ site.url }}/assets/img/数据库/5.11.png)

　　由于id到name是从左边依次往右边匹配，这两个字段中的值都是有序的，所以也遵循最左匹配原则，通过key字段可知，在搜索过程中也使用到了联合索引，但使用的是联合索引中的（id_name）索引，因为key_len字段值为16，而(id_name)索引的长度正好为16（因为id为int型，允许null，所以占5个字节，name为char(10)，允许null，又使用的是latin1编码，所以占11个字节）。

![img]({{ site.url }}/assets/img/数据库/5.12.png)

　　由于上面三个搜索都是从最左边id依次向右开始匹配的，所以都用到了id_name_age_index联合索引。

　　那如果不是依次匹配呢？

![img]({{ site.url }}/assets/img/数据库/5.13.png)

　　通过key字段可知，在搜索过程中也使用到了联合索引，但使用的是联合索引中的（id）索引，从key_len字段也可知。因为联合索引树是按照id字段创建的，但age相对于id来说是无序的，只有id只有序的，所以他只能使用联合索引中的id索引。

![img]({{ site.url }}/assets/img/数据库/5.14.png)

　　通过观察发现上面key字段发现在搜索中也使用了id_name_age_index索引，可能许多同学就会疑惑它并没有遵守最左匹配原则，按道理会索引失效，为什么也使用到了联合索引？因为没有从id开始匹配，且name单独来说是无序的，所以它确实不遵循最左匹配原则，然而从type字段可知，它虽然使用了联合索引，但是它是对整个索引树进行了扫描，正好匹配到该索引，与最左匹配原则无关，**一般只要是某联合索引的一部分，但又不遵循最左匹配原则时，都可能会采用index类型的方式扫描，但它的效率远不如最做匹配原则的查询效率高，index类型类型的扫描方式是从索引第一个字段一个一个的查找，直到找到符合的某个索引，与all不同的是，index是对所有索引树进行扫描，而all是对整个磁盘的数据进行全表扫描**。

**3.匹配列前缀**

　　如果id是字符型，那么前缀匹配用的是索引，中坠和后缀用的是全表扫描。

```sql
select * from staffs where id like 'A%';//前缀都是排好序的，使用的都是联合索引
select * from staffs where id like '%A%';//全表查询
select * from staffs where id like '%A';//全表查询
```

**4.匹配范围值**

![img]({{ site.url }}/assets/img/数据库/5.15.png)

 　在匹配的过程中遇到<>=号，就会停止匹配，但id本身就是有序的，所以通过possible_keys字段和key_len 字段可知，在该搜索过程中使用了联合索引的id索引（因为id为int型，允许null，所以占5个字节），且进行的是rang范围查询。

![img]({{ site.url }}/assets/img/数据库/5.16.png)

　　由于不遵循最左匹配原则，且在id<4的范围中，age是无序的，所以使用的是index全索引扫描。

![img]({{ site.url }}/assets/img/数据库/5.17.png)

 　不遵循最左匹配原则，但在数据库中id<2的只有一条（id），所以在id<2的范围中，age是有序的，所以使用的是rang范围查询。

![img]({{ site.url }}/assets/img/数据库/5.18.png)

 　不遵循最左匹配原则，而age又是无序的，所以进行的全索引扫描。

下面是一些关于B-Tree索引的限制：

1. 如果不是按照索引的**最左列**开始查找，则无法使用索引。
2. 不能**跳过索引**中的列。
3. 如果查询中有某个列的**范围查询**，则其**右边所有列都无法使用索引优化查找**。如有查询WHERE last_name=’Smith’ AND first_name LIKE ‘J%’ AND dob = ‘1976-12-23’，这个查询条件只能使用索引的前两列，因为这里LIKE是一个范围条件。在优化的时候，**可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。**

#### 1.3.2、哈希索引

>  哈希索引基于哈希表实现，只有精确索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希存储在索引中，同时在哈希表中保存指向每个数据的指针。 

 假设创建如下一个表： 

```mysql
CREATE TABLE testhash (
   fname VARCHAR(50) NOT NULL,
   lname VARCHAR(50) NOT NULL,
   KEY USING HASH(fname)
) ENGINE=MEMORY;
```

 包含的数据如下： 

![]({{ site.url }}/assets/img/数据库/5.19.jpg)

 假设索引使用hash函数f( )，如下： 

```sql
f('Arjen') = 2323
f('Baron') = 7437
f('Peter') = 8784
f('Vadim') = 2458
```

![]({{ site.url }}/assets/img/数据库/5.20.jpg)

此时，索引的结构大概如下：

**哈希索引中存储的是：哈希值+数据行指针** 

 InnoDB引擎有一个特殊的功能叫做“**自适应哈希索引**”。当InnoDB注意到某些索引值被使用得非常频繁时，它会在内存中基于B-Tree索引上再创建一个哈希索引，这样就像B-Tree索引也具有哈希索引的一些优点，比如快速的哈希查找。 

   **哈希冲突**（不同索引列会用相同的哈希码）会影响查询速度，此时需遍历索引中的行指针，**逐行进行比较**。如果哈希冲突很多，一些索引维护操作的代价会很高。

![]({{ site.url }}/assets/img/数据库/5.21.png)

**哈希索引限制**

1. 哈希索引只保存哈希码和指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过访问内存中的行速度非常快（因为是MEMORY引擎），所以对性能影响并不大
2. 哈希索引数据并不是按照索引值顺序存储的，所以无法用于排序
3. 哈希索引不支持部分索引列查找，因为哈希索引始终是使用索引列的全部内容来计算哈希码。 如，在数据列（A,B）上建立哈希索引，如果查询只有数据列A，则无法使用该哈希索引
4. 哈希索引只支持等值比较查询，包括=、IN()、<=>，不支持范围查询，如where price > 100
5. 哈希冲突（不同索引列会用相同的哈希码）会影响查询速度，此时需遍历索引中的行指针，**逐行进行比较**。

#### 1.3.3、空间数据索引

​     MyISAM表支持空间索引，可以用作地理数据存储。和B-Tree索引不同，这类索引无须前缀查询。空间索引会从所有维度来索引数据。查询时，可以有效地使用任何维度来组合查询。必须使用MySQL的GIS相关函数如MBRCONTAINS()等来维护数据。MySQL的GIS支持不完善。建议用开源关系数据库系统中对GIS的解决方案做的比较好的PostgreSQL的PostGIS。

#### 1.3.4、全文检索

全文索引是一种特殊的类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。它有许多需要注意的细节。如停用词、词干和复数、布尔搜索等。全文索引更类似于搜索引擎做的事情，而不是简单的WHERE条件匹配。在相同的列上同时创建全文索引和基于值得B-Tree索引不会有冲突，全文索引适用于MATCH AGAINST操作，而不是普通的WHERE条件操作。

#### 1.3.5、其他索引类别

TokuDB使用分形树索引，这是一类较新开发的数据结构，既有B-Tree的很多优点，也避免了B-Tree的一些缺点。如果通读完本章，可以看到很多关于InnoDB的主题，包括聚簇索引，覆盖索引等。多数情况下，针对InnoDB的讨论也都适用于TokuDB。

## 2、高性能的索引策略

### 2.1、独立的列

​    如果查询中的列不是独立的，则MySQL就不会使用索引。**“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数**。

```mysql
如:SELECT actor_id FROM actor WHERE actor_id + 1 = 5; 
```

 其实WHERE中等价于actor_id = 4，但**MySQL不会自动解析**。所以我们应该养成简化WHERE条件的习惯，始终将索引列单独放在比较符号的一侧。 

### 2.2、前缀索引和索引选择性

​     有时候需要索引很长的字符串，这样让索引变得大且慢。通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样会降低索引的选择性。一般情况下某个列前缀的选择性也是足够高的，足以满足查询性能。对于BLOG、TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间）。**前缀应该足够长，以使得前缀索引的选择性接近于索引整个列**。换句话说，前缀的“基数”应该接近于完整列的“基数”。 

### 2.3、 多列索引

集中精力优化索引的顺序。

### 2.4、选择合适的索引列顺序

   在一个多列B-Tree索引中，索引列的顺序意味着**索引首先按照最左列进行排序**，其次是第二列，等等。所以，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的ORDER BY、GROUP BY和DISTINCT等子句的查询需求。对于如何选择索引的列顺序有一个经验法则：**将选择性最高的列放到索引最前列**，但通常不如避免随机IO和排序那么重要。我们知道有时排序需要占用很多时间。**当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的**。这时候索引的作用只是用于优化WHERE条件的查找。然而，性能不只是依赖于所有索引列的选择性（整体基数），也和查询条件的具体值有关，也就是和值得分布有关。可能需要根据那些运行频率最高的查询来调整索引列的顺序，让这种情况下索引的选择性最高。

以下面的查询为例：

```mysql
SELECT * FROM payment WHERE staff_id = 2 AND customer_id = 584;
```

是应该创建一个（staff_id,customer_id)索引还是应该颠倒一下顺序？可以跑一些查询来确定在这个表中值得分布情况，并且确定哪个列的选择性更高。先用下面的查询预测一下。看看各个WHERE条件的分支对应的数据基数有多大：

![在这里插入图片描述]({{ site.url }}/assets/img/数据库/5.3.png)
根据前面的经验法则：应该将索引列customer_id放到前面，因为对应条件值的customer_id数量更小。我们再来看看对于这个customer_id的条件值，对应的staff_id列的选择性如何：
![在这里插入图片描述]({{ site.url }}/assets/img/数据库/5.4.png)
这样做有一个地方需要注意，查询的结果非常依赖于选定的具体值。如果按上述办法优化，可能对其他一些条件值得查询不公平，服务器的整体性能可能变得更糟，或者其他某些查询的运行变得不如预期。

这样做有一个地方需要注意，查询的结果非常依赖于选定的具体值。如果按上述办法优化，可能对其他一些条件值得查询不公平，服务器的整体性能可能变得更糟，或者其他某些查询的运行变得不如预期。

如果是从诸如pt-query-digest这样的工具的报告中提取“最差”查询，那么再按上述办法选定的索引顺序往往是非常高效的。如果没有类似的具体查询来运行，那么最好还是按经验法则来做，因为经验法则则考虑的是全局基数和选择性，而不是某个具体查询：
![在这里插入图片描述]({{ site.url }}/assets/img/数据库/5.5.png)
customer_id的选择性更高，所以答案是将其作为索引列的第一列：

```mysql
ALTER TABLE payment A
DD KEY(customer_id, staff_id);
```

### 2.5、聚簇索引

​    聚簇索引**不是单独的索引类型，而是一种数据存储方式**。InnoDB的聚簇索引实际上在同一个结构中**保存了B-Tree索引**和**数据行**。
当表有聚簇索引时，它的**数据行实际上存放在索引的叶子页中**。术语“聚簇”表示数据行和相邻的键值紧凑地存在一起。InnoDB将通过主键聚集数据，这也就是说图5-3中的“被索引的列”就是主键列。如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。InnoDB只聚集在同一个页面中的记录。包含相邻键值得页面可能会相距甚远。所以，聚簇主键可能对性能有帮助，但也可能导致严重的性能问题。 

![]({{ site.url }}/assets/img/数据库/5.6.png)

聚集的数据有一些重要的优点：

1. 可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件可能导致一次磁盘I/O。
2. 数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快。
3. 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。

如果在设计表和查询时能充分利用上面的优点，那就能极大地提升性能。同时，聚簇索引也有一些缺点：

1. 聚簇数据最大限度地提高了I/O密集型应用的性能，但如果数据全部都放在内存中，则访问顺序就没有那么重要，聚簇索引则没啥优势。这是充分利用了不同的存储介质。
2. 插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用OPTIMIZE TABLE命令重新组织一下表。
3. 更新聚簇索引的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。
4.  基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临"页分裂”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将给页分裂成两页来容纳该行，这就是页分裂。页分裂会导致表占用更多的磁盘空间。
5.  聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。
6.  二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。

### 2.6、覆盖索引

通常大家都会根据查询的WHERE条件来创建合适的索引，不过这只是索引优化的一个方面。设计优秀的索引应该考虑到整个查询，而不单单是WHERE条件的部分。**如果索引的叶子节点中已经包含要查询的数据，那么就没有必要回查表**。**如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称为覆盖索引。**
覆盖索引是非常有用的工具，能够极大地提高性能。考虑一下如果查询只需要扫描索引而无须回表，会带来以下好处：

1. 索引条目通常远小于数据行大小，所以如果只需要读取索引，那MySQL就会极大地减少数据访问量。这对缓存的负载非常重要，因为这种情况下响应时间大部分花费在数据拷贝上。覆盖索引对于I/O密集型的应用也有帮助，因为索引比数据更小，更容易全部放在内存中。
2. 因为索引是按照列值顺序存储的（至少在单个页内是如此），所以对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少很多。
3. 一些存储引擎如MyISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用。
4. 由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。**InnoDB的二级索引在叶子节点中保存了行的主键值**，所以如果二级主键能够覆盖查询，则可避免对主键索引的二次查询。不是所有类型的索引都可以成为覆盖索引。**覆盖索引必须要存储列的值**，而哈希索引、空间索引和全文索引等都不存在索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引。

### 2.7、 使用索引扫描来做排序

​       MySQL有两种方式可以生成有序的结果：（1）通过排序操作；（2）或者按索引顺序扫描；如果EXPLAIN 出来的type列的值为“index”。则说明MySQL出来的type列的值为“index”，则说明MySQL使用了索引扫描来做排序。如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就都回表查询一次对应的行。这基本上都是随机I/O，因此按索引顺序读取数据的速度通常要比顺序地全表扫描慢，尤其是在I/O密集型的工作负载时。
​MySQL可以使用同一个索引既满足排序，又用于查找行。因此，如果可能，设计索引时应该尽可能地同时满足这两种任务。只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。ORDER BY子句和查找型查询的限制是一样的：需要满足索引的最左前缀的要求；否则MySQL都需要执行排序操作，而无法利用索引排序。

有一种情况下ORDERY BY子句可以不满足索引的最左前缀的要求， 就是前导列为常量的时候，如果WHERE子句或者JOIN子句中对这些列指定了常量，就可以“弥补”索引的不足。

### 2.8、冗余索引带来的性能问题

​     MySQL允许在**相同列上创建多个索引**。重复索引是指在相同的列上按照相同的顺序创建相同类型的索引。应该**避免这样创建重复索引**，发现以后也应该立即移除。

 有时会在不经意间创建了重复索引，例如下面的代码： 

```mysql
CREATE TABLE test (
ID INT NOT NULL PRIMARY KEY,
A INT NOT NULL,
B INT NOT NULL,
UNIQUE(ID),
INDEX(ID)
) ENGINE=InnoDB;
```

   上面的写法其实创建了三个重复的索引，事实上，MySQL的唯一限制和主键限制都是通过索引实现的。

   冗余索引和重复索引有一些不同。如果创建了索引（A，B），再创建索引（A）就是冗余索引。因为这只是前一个索引的前缀索引。还有一种情况是将一个索引扩展为（A，ID），其中ID是主键，对于InnoDB来说主键列已经包含在二级索引中了，所以这也是冗余的。但有时出于性能方面的考虑需要冗余索引，因为扩展已有的索引会导致其变得太大，从而影响其他使用该索引的查询的性能。例如，如果在整数列上游一个索引，现在需要额外增加一个很长的VARCHAR列来扩展该索引，那性能可能会急剧下降。

### 2.9、未使用的索引

有一些完全没有使用的索引，建议删除。有两个工具可以帮助定位未使用的索引。最简单有效的办法是在Percana Server或者MariaDB中先打开userstates服务器变量（默认是关闭的），然后让服务器正常运行一段时间，再通过查询INFORMATION_SCHEMA.STATISTICS就能查询到每个索引的使用频率。

### 2.10、索引和锁

索引可以让查询锁定更少的行。如果你的查询从不访问那些不需要的行，那么就会锁定更少的行，从两个方面来看这对性能都有好处。

但是MySQL有时会使用间隙锁锁住不需要的数据。如果不能使用索引查找和锁定行的话就可能会更糟糕。MySQL会做全表扫描并锁住所有的行。
关于InnoDB、索引和锁有一些很少有人知道的细节：InnoDB在二级索引上使用共享（读）锁，但访问主键索引需要排他（写）锁。这消除了使用覆盖索引的可能性，并且使得SELECT FOR UPDATE 比 LOCK IN SHARE MODE或非锁定查询要慢很多。

## 3、索引案例

如果MySQL使用某个索引进行范围查询，也就无法再使用另一个索引（或者是该索引的后续字段）进行排序了。

### 3.1 、支持多种过滤条件

​    现在需要看看哪些列拥有很多不同的取值，哪些列在WHERE子句中出现得最频繁。在有更多不同值的列上创建索引的选择性会更好。一般来说这样做是对的，因为可以让MySQL更有效地过滤掉不需要的行。
​country列的选择性不高，但可能很多查询都会用到。sex列的选择性肯定很低，但也会在很多查询中用到。所以考虑到使用的频率，还是建议在创建不同组合索引的时候将（sex, country）列作为前缀。

### 3.2、避免多个范围条件

   在这个案例中，优化器的特性是影响索引策略的一个很重要的因素。如果未来版本的MySQL能够实现松散索引扫描，就能在一个索引上使用多个范围条件，那也就不需要为上面考虑的这类查询使用IN()列表了。

### 3.3、优化排序

我们经常会遇到在翻页时，越往后面的分页，MySQL需要花费大量的时间来扫描丢弃的数据，需要的成本就越高。

## 4、参考资料

https://blog.csdn.net/gonghaiyu/article/details/107805165

