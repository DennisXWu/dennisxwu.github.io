---
title: Redis学习(11)—AOF和RDB
date: 2021-1-25 23:29:53
categories:
- 大数据
tags:
- 大数据
---

## 1、RDB

 RDB持久化功能，可以将Redis在内存中的数据库状态保存到磁盘里面，既可以手动执行，也可以根据配置定期执行，**该功能可以将某一个时间点上的数据库状态保存带一个RDB文件上**。RDB文件是一个经过压缩的二进制文件。

### 1.1、RDB文件的创建与载入

有两个Redis命令可以用于生成RDB文件：

- SAVE，该命令会阻塞Redis服务器进程，直到RDB文件创建完成为止，在此期间，服务器不能处理任何客户端命令请求
- BGSAVE，BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求

 RDB文件的载入工作是在**服务器启动时自动执行**的，所以Redis**并没有专门用于载入RDB文件的命令**，只要Redis服务器在启动时检测到RDB文件存在，它就会**自动载入RDB文件**。**服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止**。

### 1.2、自动间隔性保存

用户可以在redis配置文件中通过 save 选项设置多个保存条件，但只要其中任意一个条件满足，服务器就会执行 BGSAVE 命令。

下面通过实例来解释下save选项的用法：



```shell
    # redis.conf 文件中有如下配置    
    save 900 1            # 服务器在 900 秒内，对数据库进行了至少1次修改
    save 300 10          # 服务器在 300 秒内，对数据库进行了至少10次修改
    save 60 10000      # 服务器在 60 秒内，对数据库进行了至少10000次修改
```

如果满足上述配置条件中的任意一个，redis服务器就会自动执行 BGSAVE 命令来进行RDB持久化。

### 1.3、RDB文件结构

完整的RDB文件包含以下部分



```shell
|REDIS|db_version|databases|EOF|check_sum|
```

- **REDIS**

作用：RDB文件标识符。通过这五个字符，程序可以在载入文件时，快速检查所载入的文件是否为RDB文件

长度：5字节，保存REDIS这五个字符

- **db_version**

作用：RDB文件的版本号。如0006代表第六版，为此次介绍的RDB文件结构的版本号

长度：4字节，值是一个字符串表示的整数

- **databases**

作用：包含0或多个数据库及其对应的键值对数据

长度：如果服务器数据库状态为空，则为0；如果不为空，则根据键值对的数量、类型和内容，长度也随之而变

- **EOF**

作用：RDB文件结束符。标志着RDB文件正文内容的结束，读入程序遇到这个值时，代表所有数据库的所有键值对都载入完毕了

长度：1字节

- **check_sum**

作用：检查RDB文件是否有出错或损坏。是程序通过对REDIS、db_version、databases、EOF四个部分的内容进行计算而出的；载入RDB文件时，会将载入数据所计算出的校验和与check_sum进行对比，从而得出是否出错

## 2、AOF

AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。

AOF持久化保存数据库状态的方法是将服务器执行的**SET、SADD、RPUSH**三个命令保存到AOF文件中。服务器在启动的时候，可以通过载入和执行AOF文件中保存的命令来还原服务器关闭之前的数据库状态。

### 2.1、AOF持久化的实现

AOF持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。

**命令追加**

当AOF持久化功能处于打开状态时，服务器在执行完一个写命令后，会以协议格式将被执行的写命令追加到服务器状态的 aof_buf缓存区的末尾。

**AOF文件的写入和同步**
为了提高文件的写入效率，在现代操作系统中，当用户调用 write 函数，将一些数据写入到文件的时候，操作系统通常会将写入数据暂时保存在一个内存缓冲区里面，等到缓冲区空间被填满，或者超过了指定的时限后，才真正地将缓冲区中的数据写入到磁盘里面。
这种做法虽然提高了效率，但也为写入数据带来了安全性问题，因为如果计算机发生停机，那么保存在内存缓冲区里面的写入数据将会丢失。
为此，系统提供了 fsync 和 fdatasync 两个同步函数，它们可以强制操作系统立刻将缓冲区中的数据写入到硬盘里边，从而确保写入数据的安全性。

Redis中通过配置 appendsync 选项的值来决定AOF文件写入和同步的行为。
appendsync 选项不同的取值产生的持久化行为以及对应的持久化效率和数据安全性如下表：

| appendsync选项的值 | 持久化行为                                                   | 效率   | 安全性                                                       |
| ------------------ | ------------------------------------------------------------ | ------ | ------------------------------------------------------------ |
| always             | 将 aof_buf 缓冲区中的所有内容写入并同步到AOF文件（保存到磁盘） | 最慢   | 最安全，即使故障停机，AOF持久化也只会丢失一个事件循环中所产生的命令数据 |
| everysec           | 将 aof_buf 缓冲区中的所有内容写入到AOF文件，如果上次同步的AOF文件的时间距离现在超过一秒钟，那么再次对AOF文件进行同步，并且这个同步操作是由一个子线程专门负责执行 | 足够快 | 故障停机，数据库也只丢失一秒钟的命令数据                     |
| no                 | 将 aof_buf 缓冲区中的所有内容写入AOF文件，但并不对AOF文件进行同步，何时同步由操作系统决定 | 最快   | 故障停机时，会丢失上次同步AOF文件之后所有写命令数据          |

### 2.2、AOF文件的载入和数据还原

**数据还原**：AOF文件中包含了重建数据库状态的所有写命令，所以服务器只要读入并重新执行一遍AOF文件里保存的写命令，就可以还原数据

**步骤：**

1. 创建一个不带网络连接的伪客户端。（为什么是为客户端：Redis的命令只能在客户端上下文中执行，为什么是不带网络连接：命令来自AOF文件而不是网络连接）
2. 从AOF文件中分析并读取一条写命令
3. 使用伪客户端执行被读出的写命令

一直执行步骤2,3 。直到AOF文件中的所有写命令都被处理完毕

### 2.3、AOF重写

**1.什么是AOF重写？**

为了解决AOF文件体积膨胀，Redis服务器创建一个新的AOF文件替代现有的AOF文件，新旧两个文件保存的数据库状态相同，但是新AOF文件不会包含冗余命令。

Redis**把新AOF文件替换旧AOF文件的功能叫 AOF文件重写**。

**2.AOF文件重写的实现**

*注意：AOF文件重写并不需要对现有的AOF文件进行如何读取，分析或写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。*

**原理：**首先从数据库中读取键现在的值，然后用一条命令记录键值对，代替之前记录这个键值对的多条命令。

**3.AOF后台重写**

**问题：**由于Redis服务器使用单个线程处理命令请求，当服务器调用aof_rewrite函数时，在重写AOF文件期间，服务器无法处理客户端发送来的命令请求

**解决：**把AOF重写程序放到子进程中执行，这样子进程重写期间，父进程可以继续处理命令请求。并且子进程带有父进程的数据副本。

那么问题又来了：在子进程进行AOF重写期间，服务器进程在处理命令请求时可能会改变数据库状态，导致服务器当前数据库状态和重写后的AOF文件保存的数据库状态不一致

为了解决数据不一致问题，Redis服务器设置了一个**AOF重写缓冲区**，这个缓冲区在创建子进程之后使用，当Redis服务器执行完一个写命令后，会同时把这个写命令发送给AOF缓冲区和AOF重写缓冲区。

在子进程执行AOF重写期间，服务器需要：

- 执行客户端发送过来的命令

- 将执行后的写命令追加到AOF缓冲区

- 将执行后的写命令追击到AOF重写缓冲区

  当子进程完成重写工作后，向父进程发送一个信号，父进程在接到这个信号后，把AOF重写缓冲区中的所有内容写到新AOF文件中，并对新的AOF文件进行改名，覆盖现有的AOF文件。