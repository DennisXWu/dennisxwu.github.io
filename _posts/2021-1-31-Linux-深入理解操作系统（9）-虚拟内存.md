---
title: 深入理解计算机系统（9）—虚拟内存
date: 2021-1-31 23:29:53
categories:
- 操作系统
tags:
- 操作系统
---

## 1、虚拟内存介绍

### 1.1、什么是虚拟内存？

> **虚拟内存**是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为**虚拟地址空间**。虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。

虚拟内存提供了以下的三个关键能力：

- 程序员在**比实际主存空间大得多的逻辑地址空间**中编写程序
- 程序执行时，把当前需要的程序段和相应的数据块调入**主存**，其他暂不用的部分存放在**磁盘**上
- 指令执行时，通过硬件将**逻辑地址**（也称虚拟地址或虚地址）转化为**物理地址**（也称主存地址或实地址）
- 在发生程序或数据访问失效(**缺页**)时，由操作系统进行主存和磁盘之间的信息交换 
- 它保护了每个进程的地址空间不被其他进程破坏

### 1.2、为什么要虚拟内存？

**一 、早期的内存分配机制**

​    在早期的计算机中，要运行一个程序，会把这些程序全都装入内存，程序都是直接运行在内存上的，也就是说程序中访问的内存地址都是实际的物理内存地址。当计算机同时运行多个程序时，必须保证这些程序用到的内存总量要小于计算机实际物理内存的大小。那当程序同时运行多个程序时，操作系统是如何为这些程序分配内存的呢？下面通过实例来说明当时的内存分配方法：

   某台计算机总的内存大小是128M，现在同时运行两个程序A和B，A需占用内存10M，B需占用内存110。计算机在给程序分配内存时会采取这样的方法：先将内存中的前10M分配给程序A，接着再从内存中剩余的118M中划分出110M分配给程序B。这种分配方法可以保证程序A和程序B都能运行，但是这种简单的内存分配策略问题很多。

![]({{ site.url }}/assets/img/Linux/5.1.png)

- **地址空间不隔离**

​     举个例子，假设我有两个程序，一个是程序A，一个是程序B。程序A在内存中的地址**假设**是0x00000000～0x00000099，程序B在内存中的地址**假设**是0x0000010～0x00000199。那么假设你在程序A中，本来想操作地址0x00000050，不小心**手残**操作了地址0x00000150，那么，不好的事情或许会发生。你影响了程序A也就罢了，你把程序B也搞了一顿。

- **程序运行时候的地址不确定**

​     因为我们程序每次要运行的时候，都是需要装载到内存中的，假设你在程序中写死了要操作某个地址的内存，例如你要地址0x00000010。但是问题来了，你能够保证你操作的地址0x00000010真的就是你**原来**想操作的那个位置吗？很可能程序第一次装载进内存的位置是0x00000000～0x00000099，而程序第二次运行的时候，这个程序装载进内存的位置变成了0x00000200～0x00000299，而你操作的0x00000010地址压根就不是属于这个程序所占有的内存。

- **内存使用率低下**

​     举个例子，假设你写了3个程序，其中程序A大小为10M，程序B为70M，程序C的大小为30M你的计算机的内存总共有100M。这三个程序加起来有110M，显然这三个程序是无法**同时**存在于内存中的。

并且最多只能够同时运行两个程序。可能是这样的，程序A占有的内存空间是0x00000000～0x00000009，程序B占有的内存空间是0x00000010～0x00000079。假设这个时候程序C要运行该怎么做？可以**把其中的一个程序换出到磁盘上**，然后再把程序C装载到内存中。假设是把程序A换出，那么程序C还是无法装载进内存中，因为内存中空闲的连续区域有两块，一块是原来程序A占有的那10M，还有就是从0x00000080～0x00000099这20M，所以，30M的程序C无法装载进内存中。那么，唯一的办法就是把程序B换出，保留程序A，但是，此时会有60M的内存无法利用起来，**很浪费**对吧。

**二、分段技术**

​     有一句话说的好：计算机科学领域的任何问题都可以通过增加一个间接的**中间层**来解决。  所以，**分段**这种技术就出现了。 

​    为了实现分段的这个技术，需要引入**虚拟地址空间**的概念。那么什么是地址空间呢？简单的说就是可以寻址的一片空间。如果这个空间是虚拟的，我们就叫做虚拟地址空间，如果这个空间是真实存在的，我们就叫做物理地址空间。虚拟地址空间是可以**任意的**大的，因为是虚拟的。而物理地址空间是真实存在的，所以是有限的。 

​    然后，分段这个技术做了一件什么事情呢？

​    它**把虚拟地址空间映射到了物理地址空间，并且你写的程序操作的是虚拟地址**。假设，程序A的虚拟地址空间是0x00000100～0x00000200。此时，不仅需要一块**连续的**物理内存来存放程序A，还需要把程序A的虚拟地址空间映射到（转换为）物理地址空间。可能，程序A的虚拟地址空间从0x00000100～0x00000200映射到了物理地址空间0x00000000～0x00000100。

![]({{ site.url }}/assets/img/Linux/5.2.png)

   那么分段的技术可以解决什么问题呢？可以解决上面1、2两个问题。

   在问题1中，假设程序A的**虚拟**地址空间是0x00000000～0x00000099，映射到的物理地址空间是0x00000600～0x00000699，程序B的**虚拟**地址空间是0x00000100～0x00000199，映射到的物理地址空间是0x00000300~~0x00000399。假设你还是手残，在程序A中操作了地址0x00000150，但是英文此时的地址0x00000150是虚拟的，而虚拟化的操作是在操作系统的掌控中的，所以，操作系统有能力判断，这个虚拟地址0x00000150是有问题的，然后阻止后续的操作。所以，**体现出了**隔离性。（另一种体现隔离性的方式就是，操作同一个虚拟地址，实际上**可能**操作的是不同的物理地址）

（注意，实际上，很可能程序A和程序B的虚拟地址都是0x00000000~0x00000099。这里的举例只是为了方便理解。）

​    问题2也很好的解决了。正是因为这种映射，使得程序**无需关注物理地址**是多少，只要虚拟地址没有改变，那么，程序就不会操作地址不当。 

但是**问题3仍然没有解决**。

因为第三个问题是换入换出的问题，这个问题的关键是能不能在换出一个**完整的**程序之后，把另一个**完整的**程序换进来。而这种分段机制，映射的是一片**连续的**物理内存，所以问题3得不到解决。

**三、分页技术**

​    而分页技术的出现就是为了解决这个问题的。分页这个技术仍然是一种虚拟地址空间到物理地址空间映射的机制。但是，**粒度更加的小了**。单位不是整个程序，而是某个“页”，一段虚拟地址空间组成的某一页映射到一段物理地址空间组成的某一页。

​    分页这个技术，它的**虚拟地址空间仍然是连续的**，但是，每一页映射后的**物理地址就不一定是连续的了**。正是因为有了分页的概念，程序的换入换出就可以以页为单位了。那么，为什么就可以只换出某一页呢？实际上，不是为什么可以换出某一页，而是可以换出CPU还用不到的那些程序代码、数据。但是，把这些都换出到磁盘，万一下次CPU就要使用这些代码和数据怎么办？又得把这些代码、数据装载进内存。性能有影响对吧。所以，我们把换入换出的单位变小，变成了“页”。（实际上，这利用了空间局部性）

### 1.3、什么是虚拟地址？

​     每个程序被运行起来后，都将拥有自己的独立**虚拟地址空间**，虚拟地址空间的大小由CPU的位数决定的。比如 32 位的硬件平台决定了虚拟地址空间为 4 GB 大小。一般来说，C 语言指针大小的位数与虚拟空间的位数相同，如 32 位平台下的指针为 32 位， 即 4 字节。64 位平台下的指针为 64 位，即 8 字节。

操作系统会提供一种机制，能够将不同进程的虚拟地址空间与不同内存的物理地址映射起来，这样所有进程都不能直接访问物理内存，都只能访问自己的虚拟内存空间。那 Linux 操作系统下 32 位平台下的 4 GB 虚拟地址空间是怎么分配的呢？

![]({{ site.url }}/assets/img/Linux/5.3.png)

​    整个 4 GB 的空间，操作系统用了 1 GB，从地址 `0XC0000000` 到 `0XFFFFFFFF`, 剩余 3 GB留给用户空间。也就是说整个进程在执行的时候，所有的代码、数据包括申请的堆栈总和不能超过 3 GB。对于占用内存空间较大的进程，3 GB的内存空间实在是偏小，现在大部分的 App 也都支持 64 位系统。 

### 1.4、什么是物理地址？

 很简单，将内存条看出一个大的数组，下标从0开始到0xFFFFFFFF，其中任意一个下标标记一个内存条上的一个字节的存储空间 

### 1.5、什么是物理内存？

> **主存**是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存储器（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址从0开始。

## 2、物理和虚拟寻址

虚拟内存主要是一种地址扩展技术，主要是建立和管理两套地址系统：**物理地址**和**虚拟地址**。由虚拟地址空间（硬盘上）装入进程，其实际执行是在物理地址空间（内存上）承载进程的执行。虚拟地址空间比物理地址空间要大的多，操作系统同时承担着管理者两套地址空间的转换。

### 2.1、物理寻址

 主存的每个地址都是唯一的，第一个字节地址为0，接下来为2，以此类推。CPU使用这种访问方式就是**物理寻址**。下图所示就是CPU通过**地址总线**传递读取主存中4号地址开始处的内容并通过数据总线传送到CPU的寄存器中。

![img]({{ site.url }}/assets/img/Linux/5.4.webp)

 当然地址总线也不是无限大的，我们通常所说的32位系统，其寻址能力是2^32 = 4 294 967 296B（4GB）也就是说内存条插的再多也没有用，**地址总线只能最多访问到4GB的地址内容**。

### 2.2、虚拟寻址

我们前面说过4GB的物理内存空间其实并不大（如果是独占的话）。这时候科学家们想到了一个很好的方法，建立虚拟寻址方式，使用一个成为MMU的地址翻译工具**将虚拟地址翻译成物理地址**在提供访问，如下图：

![img]({{ site.url }}/assets/img/Linux/5.5.webp)

使用虚拟寻址的时候，cpu先是生成一个虚拟地址：4100再经过地址翻译器，将4100翻译成物理地址。

我们说过虚拟地址要比物理地址大的多，为啥还要麻烦的将物理地址转成虚拟地址呢？虚拟地址的发明究竟是为了什么，我们知道对内存的访问要比硬盘的访问快10000倍，如果我们在内存中没有找到相应的内容（不命中），而需要到硬盘上找的话，我们必须要提供相对来说高效率的访问方式。这时候就**创建了一个虚拟存储器**，管理着磁盘，以**每页的方式**进行整合，每个页面的大小4kb-2mb不等，加上偏移量就成为了一个虚拟地址。比如4100，说明的就是页4编号，偏移100处的位置。这就比挨个挨个单独寻址要快的多。

### 2.3、地址空间

**地址空间**是一个非负数地址的有序集合：如果地址空间的整数是连续的，那么我们说它是一个**线性地址空间**。那么一个拥有虚拟寻址的CPU，也就会有一个**虚拟地址空间。**内存中的一个字节，就会有一个物理地址和一个虚拟地址。如果CPU有N个虚拟地址空间，那么该字节就有N个虚拟地址。

## 3、虚拟内存作为缓存的工具

### 3.1、虚拟页

​    虚拟内存被组织为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，作为到数组的索引。磁盘上数组的内容被缓存在主存中。和存储器层次结构中其他缓存一样，磁盘（较低层）上的数据被分割成块，这些块作为磁盘和主存（较高层）之间的传输单元。VM 系统通过将虚拟内存分割为称为**虚拟页**（Virtual Page，VP）的大小固定的块来处理这个问题。每个虚拟页的大小为 P=2p\small P = 2^pP=2p 字节。类似地，物理内存被分割为**物理页**（Physical Page，PP），大小也为 P 字节（物理页也被称为**页帧**（page frame））。

在任意时刻，虚拟页面的集合都分为三个不相交的子集：

- **未分配的：**VM 系统还未分配（或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。
- **缓存的：**当前已缓存在物理内存中的已分配页。
- **未缓存的：**未缓存在物理内存中的已分配页。

![]({{ site.url }}/assets/img/Linux/5.6.png)

### 3.2、页表

​      页表是一个存放在**内存**中的数据结构，MMU就是**通过页表来完成虚拟地址到物理地址的转换**。这个数据结构每一个条目称为PTE（Page Table Entry），由两部分组成：**有效位**和**n位地址段**。有效位如果是1，那么n位地址就指向已经在内存中缓存好了的地址；如果为0，地址为null的话表示为分配，地址指向磁盘上的虚拟内存（pagefile.sys）的话就是未缓存。我们来看一个典型的页表图： 

![]({{ site.url }}/assets/img/Linux/5.7.png)

​    虚拟页vp1,2,7,4当前被缓存在内存中，页表上有效位设置成1，分别用PTE1，2，4，7表示。VP0和VP5（PTE0、5）未被分配，VP3和VP6被分配并指向虚拟内存，但未被缓存。 

### 3.3、页命中

![]({{ site.url }}/assets/img/Linux/5.8.png)

​    当我们使用2100虚拟地址来访问虚拟页2的内容的时候，就是一个页命中。地址翻译将指向PTE2上，由于有效位1，地址翻译器MMU就知道VP2已经缓存在内存中了。就使用页表中保存的物理地址进行访问。 

### 3.4、缺页

![]({{ site.url }}/assets/img/Linux/5.9.png)

我们再来看看不命中，也就是缺页的情况，当CPU需要VP3的一个字时，初始化是这样的：

PTE3有效位是0，同时地址位指向了虚拟内存（pagefile.sys），就会触发缺页异常。

异常处理程序会选择牺牲一个内存（DRAM）中的页，本例中选择的是内存中的PP3页的VP4，如果VP4已经被修改了，那么内核就会将它复制回磁盘。无论哪种情况，内核都会修改VP4的页表条目，反映VP4不再缓存在内存这一事实。接下来内核就从虚拟内存中拷贝VP3到内存中的PP3，并使得PTE3指向内存中的PP3，形成如下：

![]({{ site.url }}/assets/img/Linux/5.10.png)

 （注：虚拟存储器出现早于高速缓存，按照习惯的说法块被叫做页。从虚拟内存到物理内存传送页的活动就叫做页面交换。） 

### 3.5、虚拟存储器的作用

虚拟存储器有诸多的好处，操作系统其实**为每个进程提供了一个独立的页表**，**使用不同的页表也就创建了独立的虚拟地址空间**，下图展示了基本思想：

![img]({{ site.url }}/assets/img/Linux/5.11.png)

 

   进程i将VP1映射到了内存的PP2处，VP2映射到了内存的PP7处。进程j将VP1映射到了内存的PP7，将VP2映射到了PP10处。

## 4、地址翻译

![img]({{ site.url }}/assets/img/Linux/5.12.png)

**地址翻译**从形式上来说就是建立一个虚拟地址空间到物理地址空间的映射关系，我们前面说过MMU使用的是页表来实现这种映射。CPU中有一个专门的页表基址寄存器（PTBR）指向当前页表，使用页表进行翻译的时候方法如下：

每个虚拟地址由两部分组成：虚拟页号（VPN）+虚拟页偏移量（VPO），当CPU生成一个虚拟地址并传递给MMU开始翻译的时候，MMU利用虚拟地址的VPN来选择相应的PTE，同时将页表中的物理页号（PPN）+虚拟地址的VPO就生成了相应的物理地址。（**物理地址是由页表中的物理页号+虚拟地址中的偏移量构成**）

![img]({{ site.url }}/assets/img/Linux/5.13.png)

页面命中是一个简单的过程，我们就不做详解，这里来跟踪看一下**缺页的情况：**

> 说明：
>
> ①CPU生成虚拟地址；
>
> ②MMU生成PTE地址从内存的页表中请求内容；
>
> ③ 内存中的页表返回相应的PTE值；
>
> ④ PTE的有效位是0，MMU触发异常，转到异常处理程序；
>
> ⑤ 异常处理程序确定内存中的牺牲页，并将其写会到磁盘上；
>
> ⑥缺页处理程序页面调入新的页面，更新PTE。
>
> ⑦ 由于PTE已经被更新好了，从新发送虚拟地址到MMU（后面就和命中的过程一样了）

 

