---
title: 反码、补码学习
date: 2021-1-8 23:29:53
categories:
- Java基础
tags:
- Java基础
---

## 1、预备知识

​       由计算机的硬件决定，任何存储于计算机中的数据，其本质都是以**二进制码**存储。根据冯~诺依曼提出的经典计算机体系结构框架。一台计算机由**运算器，控制器，存储器，输入**和**输出**设备组成。其中运算器，只有**加法运算器，没有减法运算器**（据说一开始是有的，后来由于减法器硬件开销太大，被废了 ）

   所以，计算机中的没法直接做减法的，它的减法是通过加法来实现的。你也许会说，现实世界中所有的减法也可以当成加法的，减去一个数，可以看作加上这个数的相反数。当然没错，但是前提是要先有**负数**的概念。这就为什么不得不引入一个的**符号位**。

## 2、原码

### 2.1、什么是原码？

> **原码：**是最简单的机器数表示法。用最高位表示符号位，‘1’表示负号，‘0’表示正号。其他位存放该数的二进制的绝对值。 

若以带符号位的四位二进值数为例 

1. 1010 ： 最高位为‘1’，表示这是一个负数，其他三位为‘010’
2. 即（0*2^2）+（1*2^1）+（0*2^0）=2（‘^’表示幂运算符）
3. 所以1010表示十进制数（-2）。

### 2.2、原码的弊端

当进行如下二进制运算：

1. 0001+0010=0011 （1+2=3）OK
2. 0000+1000=1000 （+0+（-0）=-0） 额，问题不大
3. 0001+1001=1010 （1+（-1）=-2） 不对

我们可以看到其实正数之间的加法通常是不会出错的，因为它就是一个很简单的二进制加法。

**而正数与负数相加，或负数与负数相加，就要引起莫名其妙的结果**。

## 3、反码？

### 3.1、反码的介绍

>**反码：**正数的反码还是等于原码，负数的反码就是他的原码除符号位外，按位取反。

若以带符号位的四位二进制数为例：

1. 3是正数，反码与原码相同，则可以表示为0011
2. -3的原码是1011，符号位保持不变，低三位（011）按位取反得（100）
3. 所以-3的反码为1100

### 3.2、为什么要反码？

​    由于原码再计算正数和负数相加，或者负数与负数相加时会出现错误。 于是，我们就在编码里引进了一个新的概念：**反码**。引入反码之后，本来是减法的运算就可以变成加法来实现。 

 3-5=3+[-5]=[-2]，中括号代表“反码”，“反码”就是我们人为给出的计算机术语。 

### 3.3、反码的例子

>于是3+[-5]=[-2]的计算过程为：[0_0000011]反+[1_1111010]反=[1_11111101]反

## 4、补码？

### 4.1、补码的介绍

> **补码：**正数的补码等于他的原码，负数的补码等于反码+1。（这只是一种算补码的方式，多数书对于补码就是这句话） 

例子如下：

​    [+1] = [00000001]原 = [00000001]反 = [00000001]补

​    [-1] = [10000001]原 = [11111110]反 = [11111111]补

### 4.2、为什么需要补码？

   前面我们推论了为何要用反码，那么用8位二进制反码表示的正数范围： +0 — +127；负数范围： -127 —-0。但是，其中有两个特殊的编码会出现：

[0_0000000]=+0 （反码）

[1_1111111]=-0 （反码）

其实，+0和-0代表的都是0。这样一来，“0”这个数字在计算机中的编码就不是唯一的了。对于计算机来说，这是绝对不行的，因为任何数字都只能有1个编码。

于是，聪明的人就做了这样一个决定：把0当成正数，也即+0，这样0的编码就变成：0_0000000。那8位二进制表示的正数范围仍然是： +0 —— +127。

但是，对于负数就必须要做调整，也即-0必须要让位---1_1111111这个编码不能表示-0。我们可以把负数整体向后“挪动1位”：只要将8位二进制表示的负数范围从：-127 —— -0变成：-128 —— -1，就能成功解决问题。

那么怎么整体挪动1位呢？方法就是反码+1。{1_1111111}编码就不再表示-0，而变成了-1。顺着推，最小的编码{1_0000000}就是-128

### 4.3、补码的例子

于是3+{-5}={-2}的计算过程为：

{0_0000011}+{1_1111011}={11111110}

