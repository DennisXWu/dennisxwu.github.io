---
title: Redis学习(8)—集群
date: 2021-1-8 23:29:53
categories:
- 大数据
tags:
- 大数据
---

## 1、节点？

   节点就是一个**运行在集群模式下的Redis服务器**，Redis服务器在启动时会根据*cluster-enabled*配置选项是否为yes来决定是否开启服务器的集群模式。

   每个节点都会使用一个clusterNode结构来记录自己的状态，并为集群中的所有其他节点(主从节点)都创建一个相应的clusterNode结构，以此来记录其他节点的状态。

![image]({{ site.url }}/assets/img/大数据/8.1.png)

> 具体步骤：
>
> 1、节点A会为jiedianB创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面；
>
> 2、节点A将根据CLUSTER MEET命令给定的IP地址和端口号，向节点B发送一条MEET消息；
>
> 3、如果一切顺利，节点B将接收到节点A发送的MEET消息，节点B会为节点A创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面，然后节点B向节点A返回一条PONG消息；
>
> 4、如果一切顺利，节点A将接收到节点B返回的PONG消息，通过这条PONG消息节点A可以知道节点B已经成功地接收到自己发送地MEET消息，然后节点A将向节点B返回一条PING消息；
>
> 5、如果一切顺利，节点B将接收到节点A返回地PING消息，通过这条PING消息节点B可以知道节点A已经成功地接收到了自己返回的PONG消息，握手完成。
>
> 之后节点A会将节点B的信息通过Gossip协议传播给集群中的其他节点，让其他节点也与节点B进行握手，最终经过一段时间之后，节点B会被集群中的所有节点认识。

## 2、什么是槽指派？

​    Redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为**16384个槽**，数据库中的每个键都属于这16384个槽的其中一个。当数据库中的16384个槽都有节点在处理时，集群处于上线状态(ok)；相反地，如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态(fail)。

![image]({{ site.url }}/assets/img/大数据/8.2.png)

​     当你往Redis Cluster中加入一个Key时，会根据*crc16(key) mod 16384*计算这个key应该分布到哪个hash slot中，**一个hash slot中会有很多key和value**。如果slots数组在索引i上的**二进制位的值为1**，表示节点负责处理槽i；如果slots数组在索引i上的**二进制位的值为0**，表示节点不负责处理槽i。

  集群中的每个节点都会将自己的slots数组通过消息发送给集群中的其他节点，并且每个接收到slots数组的节点都会将数组保存到相应节点的clusterNode结构里面，**因此集群中的每个节点都会知道数据库中的16384个槽分别被指派给了集群中的哪些节点**。

   clusterState.slots数组记录了集群中所有槽的指派信息，而clusterNode.slots数组只记录了clusterNode结构所代表的节点的槽指派信息。当程序需要将某个节点的槽指派信息通过消息发送给其他节点时，程序只需要将相应节点的clusterNode.slots数组整个发送出去；当程序要检查槽i是否已经被指派，又或者取得负责处理槽i的节点，只需要访问clusterState.slots[i]的值即可，这个操作的复杂度仅为O(1)。

## 3、重新分片

​    Redis集群的重新分片操作可以将任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点移动到目标节点。
   **重新分片可以在线进行，在重新分片的过程中，集群不需要下线，**并且源节点和目标节点都可以继续处理命令请求。

![]({{ site.url }}/assets/img/大数据/8.3.png)

>  Redis集群的重新分片操作是由Redis的集群管理软件 redis-trib负责执行的，Redis提供了进行重新分片所需的所有命令，而 redis-trib则通过向源节点和目标节点发送命令来进行重新分片操作。
>  redis-trib对集群的单个槽slot进行重新分片的步骤如下∶
>  1）redis-trib对目标节点发送CLUSTER SETSLOT<slot>IMPORTING <source_id>命令，让目标节点准备好从源节点导入（import）属于槽slot的键值对。
>  2）redis-trib对源节点发送CLUSTER SETSLOT <slot>MIGRATING<target_id>命令，让源节点准备好将属于槽 slot的键值对迁移（migrate）至目标节点。
>  3）redis-trib向源节点发送CLUSTER GETKEYSINSLOT<slot><count>命令，获得最多 count 个属于槽 slot 的键值对的键名（key name）。
>  4）对于步骤3获得的每个键名，redis-trib都向源节点发送一个MIGRATE <target_ip><target_port><key_name>0<timeout>命令，将被选中的键原子地从源节点迁移至目标节点。
>  5）重复执行步骤3和步骤4，直到源节点保存的所有属于槽slot的键值对都被迁移至目标节点为止。每次迁移键的过程如图17-24所示。
>  6）redis-trib向集群中的任意一个节点发送CLUSTER SETSLOT<stlo> NODE <targetid>命令，将槽slot指派给目标节点，这一指派信息会通过消息发送至整个集群，最终集群中的所有节点都会知道槽 slot 已经指派给了目标节点。

## 4、ASK错误

### 4.1、ASK错误

​      在进行重新分片期间，源节点向目标节点迁移一个槽的过程中，可能会出现这样一种情况：**属于被迁移槽的一部分键值对保存在源节点里面，而另一部分键值对则保存在目标节点 里面**

当客户端向源节点发送一个与数据库键有关的命令，并且命令

**要处理的数据库键恰好就属于正在被迁移的槽时：**

- 源节点会先在自己的数据库里面查找指定的键，**如果找到的话，就直接执行客户端发送的命令**（底层实现：如果节点收到一个关于键key的命令请求，并且键key所属的槽i正好就指派给了这个节 点，那么节点会尝试在自己的数据库里查找键key，如果找到了的话，节点就直接执行客户 端发送的命令）
- 相反地，如果源节点没能在自己的数据库里面找到指定的键，那么这个**键有可能已经被迁移到了目标节点**，源节点**将向客户端返回一个ASK错误**，**指引客户端转向正在导入槽的目标节点**，并再次发送之前想要执行的命令（底层实现：如果节点没有在自己的数据库里找到键key，那么节点会检查自己的 clusterState.migrating_slots_to[i]，看键key**所属的槽i是否正在进行迁移**，如果槽i的确在进行 迁移的话，那么节点会向客户端发送一个ASK错误，引导客户端到正在导入槽i的节点去查找 键key）

### 4.2、ASKING命令（REDIS_ASKING标识）

**ASKING命令功能：**唯一要做的就是**打开发送该命令的客户端的REDIS_ASKING标识**

   **REDIS_ASKING标识：**在一般情况下，如果客户端向节点发送一个关于槽i的命令，而槽i又没有指派给这个节点的话，那么节点将向客户端返回一个MOVED错误；但是，如果节点的 clusterState.importing_slots_from[i]显示节点正在导入槽i，并且发送命令的客户端带有REDIS_ASKING标识，那么节点将破例执行这个关于槽i的命令一次，下图展示了这个判 断过程：

![image]({{ site.url }}/assets/img/大数据/8.4.png)

- 当客户端接收到ASK错误并转向至正在导入槽的节点时，客户端会先向节点发送一个 ASKING命令，然后才重新发送想要执行的命令，这是**因为如果客户端不发送ASKING命令**，而直接发送想要执行的命令的话，那么**客户端发送的命令将被节点拒绝执行，并返回 MOVED错误**
- 另外要注意的是，客户端的REDIS_ASKING标识是一个一次性标识，当**节点执行了一个带有REDIS_ASKING标识的客户端发送的命令之后，客户端的REDIS_ASKING标识就会被移除**

## 5、复制和故障转移

### 5.1、节点复制  

 redis集群中的节点分为主节点master和从节点slave,其中**主节点主要用于处理槽，而从节点则用于复制某个主节点**，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。

​    通过向一个节点发送 CLUSTER REPLICATE <node_id> 可以让接收命令的节点称为node_id所指定节点的从节点，并开始对主节点进行复制。

   一个节点成为从节点，并开始复制某个主节点，这一信息会通过消息发送给集群中的其他节点，最终集群中的所有节点都会知道某个从节点正在复制某个主节点。

### 5.2、故障检测

1、集群中的每个节点都会定期的向集群中的其他节点发送PING消息，以此来检测对方是否在线。

2、如果接收方没有在规定的时间内向发送PING消息的节点返回PONG消息，那么发送PING消息的节点就会将接收PING消息的节点标记为疑似下线。

3、集群中的各个节点会通过相互发送消息的方式来交换集群中各个节点的状态信息，例如：某个节点是处于在线状态、疑似下线PFAIL，还是已下线状态FAIL。

4、如果在一个集群里面，半数以上负责处理槽的主节点都将某个主节点x报告为疑似下线，那么这个主节点x将被标记为已下线FAIL，将主节点x标记为已下线的节点会向集群广播一条关于主节点x的FAIL消息，所有收到这条FAIL消息的节点都会立即将主节点x标记为已下线。

### 5.3、故障转移

当一个从节点发现自己正在复制的主节点进入了已下线状态时，从节点将开始对下线节点进行故障转移。

1、选举新的主节点
复制下线主节点的所有从节点里面，会有一个从节点被选中作为新的主节点

2、被选中的从节点会执行SLAVEOF no one命令，称为新的主节点。

3、新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽指派给自己。

4、新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即致电这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本已下线节点负责处理的槽。

5、新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。

## 6、消息

- MEET 消息：通过CLUSTER MEET命令，请求接收者加入到发送者当前所处的集群里面。
- PING消息：检测集群节点是否在线
- PONG消息：对发送MEET或者PING消息的发送者返回PONG消息以确认消息收到。另外一个节点也可以向集群广播自己的PONG消息来让集群中的其他节点立即刷新关于这个节点的认识。
- FAIL消息：当一个主节点A判断另一个主节点B进入FAIL状态时，节点A会向集群广播一条关于节点B的FAIL消息，所有接收到这条消息的节点会立即将节点B标记为已下线。
- **PUBLISH消息**：当节点接收到一个PUBLISH命令时，节点会执行这个命令并向集群广播一条PUBLISH消息，所有接收到这条PUBLISH消息的节点都会执行相同的PUBLISH命令。
