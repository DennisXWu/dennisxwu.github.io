---
title: 高性能MySQL学习（1）—MySQL架构和历史
date: 2021-1-21 23:29:53
categories:
- 数据库
tags:
- 数据库
---

## 1、MySQL的逻辑架构

 MySQL服务器逻辑架构图： 

![]({{ site.url }}/assets/img/数据库/4.1.png)

1. 第一层**负责连接管理、授权认证、安全**等等。
   每个客户端的连接都对应着服务器上的一个线程。服务器上维护了一个**线程池**，避免为每个连接都创建销毁一个线程。当客户端连接到MySQL服务器时，服务器对其进行认证。可以通过**用户名和密码**的方式进行认证，也可以通过SSL证书进行认证。登录认证通过后，服务器还会验证该客户端是否有执行某个查询的权限。
2. 第二层负责**解析查询(编译SQL)**，并对其进行**优化(如调整表的读取顺序，选择合适的索引等)**。对于SELECT语句，在解析查询前，服务器会先检查**查询缓存**，如果能在其中找到对应的查询结果，则无需再进行查询解析、优化等过程，直接返回查询结果。存储过程、触发器、视图等都在这一层实现。
3. 第三层是**存储引擎**，存储引擎负责在MySQL中**存储数据、提取数据**、开启一个事务等等。存储引擎通过API与上层进行通信，这些API屏蔽了不同存储引擎之间的差异，使得这些差异对上层查询过程透明。存储引擎不会去解析SQL。

## 2、并发控制

### 2.1、读写锁

在处理并发读或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁通常被称为共享锁（shared lock）和排他锁（exclusive lock），也叫**读锁（read lock）**和**写锁（write lock）**。

锁的概念如下：

**读锁是共享的**，或者说是相互不阻塞的。多个客户在同一时刻可以同时读取同一个资源，而互不干扰。

**写锁则是排他的**，也就是说一个写锁会阻塞其他的写锁和读锁，这是出于安全策略的考虑，只有这样，才能确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。

在实际的数据库系统中，每时每刻都在发生锁定，当某个用户在修改某一部分数据时，MySQL会通过锁定防止其他用户读取同一数据。大多数时候，MySQL锁的内部管理都是透明的（自动加锁）。

### 2.2、锁粒度

​       一种提高共享资源并发性的方式就是**让锁定对象更有选择性**。尽量只锁定需要修改的部分数据，而不是所有的资源。更理想的方式是，只**对会修改的数据片进行精确的锁定**。任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相互之间不发生冲突即可。

MySQL则提供了多种选择。每种MySQL存储引擎都可以实现自己的**锁策略**和**锁粒度**。

- 表锁

​      **表锁是MySQL中最基本的锁策略，并且是开销最小的策略**。它会锁定整张表，一个用户在对表进行写操作（插入、删除、更新等）前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有**没有写锁时，其他读取的用户才能获得读锁**，读锁之间是不相互阻塞的。

在特定的场景中，表锁也可能有良好的性能。例如，READ LOCAL表锁支持某些类型的并发写操作。另外，**写锁也比读锁有更高的优先级**，因此一个写锁请求可能会被插入到读锁队列的前面（**写锁可以插入到锁队列中读锁的前面，反之读锁则不能插入到写锁的前面**）。

尽管存储引擎可以管理自己的锁，MySQL本身还是会使用各种有效的表锁来实现不同的目的。例如，服务器会为诸如ALTER TABLE之类的语句使用表锁，而忽略存储引擎的锁机制。

> 表锁的优势：开销小；加锁快；无死锁
> 表锁的劣势：锁粒度大，发生锁冲突的概率高，并发处理能力低
> 加锁的方式：自动加锁。查询操作（SELECT），会自动给涉及的所有表加读锁，更新操作（UPDATE、DELETE、INSERT），会自动给涉及的表加写锁。也可以显示加锁：
> 共享读锁：lock table tableName read;
> 独占写锁：lock table tableName write;
> 批量解锁：unlock tables;

- 行级锁

**行级锁可以最大程度地支持并发处理（同时也带来了最大的锁开销）**。在**InnoDB和XtraDB**，以及其他一些存储引擎中实现了行级锁。**行级锁只在存储引擎层实现，而MySQL服务器层没有实现**。服务器层完全不了解存储引擎中的锁实现，所有的存储引擎都以自己的方式显现了锁机制。

> 行锁的劣势：开销大；加锁慢；会出现死锁
> 行锁的优势：锁的粒度小，发生锁冲突的概率低；处理并发的能力强
> 加锁的方式：自动加锁。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁；对于普通SELECT语句，InnoDB不会加任何锁；当然我们也可以显示的加锁：
> 共享锁：select * from tableName where ... + lock in share mode
> 排他锁：select * from tableName where ... + for update 

 **InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁。** 

- 间隙锁

**在行级锁的基础上**，当用范围条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做"间隙(GAP)"。InnoDB也会对这个"间隙"加锁，这种锁机制就是所谓的间隙锁(Next-Key锁)。

```mysql
# 事务1
mysql> update innodb_lock set k=66 where id >=6;
Query OK, 1 row affected (0.33 sec)
mysql> commit;
 
# 事务2
mysql> insert into innodb_lock (id,k,v) values(8,'8','8000');
Query OK, 1 row affected (12.99 sec)
```

第一个事务锁住了不存在的id，导致第二个事务执行插入时阻塞。

危害(坑)：若执行的条件是范围过大，则InnoDB会将整个范围内所有的索引键值全部锁定，很容易对性能造成影响。

## 3、事务

### 3.1、ACID

- A（**原子性**）：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 
- C（**一致性**）:  指事务将数据库从一种状态转变为另一种一致的的状态。事务开始前和结束后，数据库的完整性约束没有被破坏。例如工号带有唯一属性，如果经过一个修改工号的事务后，工号变的非唯一了，则表明一致性遭到了破坏。  
- I（**隔离性**）：  两个事务的执行是互不干扰的，一个事务不可能看到其他事务运行时，中间某一时刻的数据。 
- D（**持久性**）： 指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃（ *事务的提交操作也不是把事务修改的数据直接写入磁盘 ，而是先写入缓存中*），重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。  MySQL 使用 `redo log` 来保证事务的持久性。 

### 3.1、事务隔离

 InnoDB默认是**可重复读**的 ,事务并发可能出现的情况：

- **脏读(Dirty Read)**

>  一个事务读到了另一个未提交事务修改过的数据 

   会话B开启一个事务，把id=1的name为武汉市修改成温州市，此时另外一个会话A也开启一个事务，读取id=1的name，此时的查询结果为温州市，会话B的事务最后回滚了刚才修改的记录，这样会话A读到的数据是不存在的，这个现象就是脏读。（脏读只在读未提交隔离级别才会出现） 

- **不可重复读（Non-Repeatable Read）**

>  一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值。（不可重复读在读未提交和读已提交隔离级别都可能会出现） 

   会话A开启一个事务，查询id=1的结果，此时查询的结果name为武汉市。接着会话B把id=1的name修改为温州市（隐式事务，因为此时的autocommit为1，每条SQL语句执行完自动提交），此时会话A的事务再一次查询id=1的结果，读取的结果name为温州市。会话B再此修改id=1的name为杭州市，会话A的事务再次查询id=1，结果name的值为杭州市，这种现象就是不可重复读。 

- **幻读（Phantom）**

>  一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。（幻读在读未提交、读已提交、可重复读隔离级别都可能会出现） 

  会话A开启一个事务，查询id>0的记录，此时会查到name=武汉市的记录。接着会话B插入一条name=温州市的数据（隐式事务，因为此时的autocommit为1，每条SQL语句执行完自动提交），这时会话A的事务再以刚才的查询条件（id>0）再一次查询，此时会出现两条记录（name为武汉市和温州市的记录），这种现象就是幻读。 

**事务的隔离级别：**

>  MySQL的事务隔离级别一共有四个，分别是读未提交、读已提交、可重复读以及可串行化。
>
> MySQL的隔离级别的作用就是让事务之间互相隔离，互不影响，这样可以保证事务的一致性。
>
> 隔离级别比较：可串行化>可重复读>读已提交>读未提交
>
> 隔离级别对性能的影响比较：可串行化>可重复读>读已提交>读未提交
>
> 由此看出，隔离级别越高，所需要消耗的MySQL性能越大（如事务并发严重性），为了平衡二者，一般建议设置的隔离级别为可重复读，MySQL默认的隔离级别也是可重复读。 

- **读未提交（READ UNCOMMITTED）**

   在读未提交隔离级别下，事务A可以读取到事务B修改过但未提交的数据。可能发生脏读、不可重复读和幻读问题，一般很少使用此隔离级别。

- **读已提交（READ COMMITTED）**

   在读已提交隔离级别下，事务B只能在事务A修改过并且已提交后才能读取到事务B修改的数据。读已提交隔离级别解决了脏读的问题，但可能发生不可重复读和幻读问题，一般很少使用此隔离级别。

- **可重复读（REPEATABLE READ）**

​    在可重复读隔离级别下，事务B只能在事务A修改过数据并提交后，自己也提交事务后，才能读取到事务B修改的数据。可重复读隔离级别解决了脏读和不可重复读的问题，但可能发生幻读问题。

- **可串行化（SERIALIZABLE）**

​    当数据库系统使用SERIALIZABLE隔离级别时，一个事务在执行过程中完全看不到其他事务对数据库所做的更新。当两个事务同时操作数据库中相同数据时，如果第一个事务已经在访问该数据，第二个事务只能停下来等待，必须等到第一个事务结束后才能恢复运行。因此这两个事务实际上是串行化方式运行。

### 3.2、死锁

> 一个资源分别被两个事务占用了，这就形成了一个典型的死锁 

在MySQL中，死锁是如何解决的呢？一般来说，数据库系统提供了两种解决死锁的办法：**死锁检测**和**死锁超时**。

**死锁检测**是如何做到的呢？数据库会检测到存在循环依赖，这个时候就表示发生了死锁，因为没有一个资源的条件能得到满足。一般来说，InnoDB能够比较迅速地检测到死锁的存在，并立即返回一个错误给用户。这种解决方式非常的有效，能够有效地避免用户进行一些无效地查询，以及慢SQL的出现。

**死锁超时**是另一种非常常规的解决思路，就是当查询的时间超过多少秒的时候，数据库引擎放弃执行这条SQL，但是这种方式不太友好，会产生大量的重复查询，浪费数据库资源。

InnoDB目前的做法就是**将数据库中持有最少行级排他锁的事务进行回滚，这样其它的事务就有机会去获取对应的资源**。

### 3.3、事务日志

- 事务日志可以帮助提高事务的效率。使用事务日志，***存储引擎在修改表的数据时只需要修改其内存拷贝***，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘
- **事务日志采用的是追加的方式**，因此写日志的操作是磁盘上一小块区域内的 顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事 务日志的方式相对来说要快得多。事务日志持久以后，内存中被修改的 数据在后台可以慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现 的，我们通常称之为预写式日志（Write-Ahead Logging），修改数据需 要写两次磁盘
- 如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时**系统崩溃，存储引擎在重启时能够自动恢复这部分修改 的数据**。具体的恢复方式则视存储引擎而定

## 4、MySQL存储引擎

### 4.1、**InnoDB**

​     InnoDB的数据存储在表空间（tablespace）中，表空间是由InnoDB管理的一个黑盒子，由一系列的数据文件组成。InnoDB可以将每个表的数据和索引存放在单独的文件中。InnoDB也可以使用裸设备作为表空间的存储介质，但现代的文件系统使得裸设备不再是必要的选择。

InnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别。其默认级别是REOEATABLE READ(可重复读)，并且通过间隙锁（next-key locking）策略防止幻读的出现。间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。

InnoDB 表是基于聚簇索引建立的，InnoDB索引结构和MySQL其他存储引擎有很大的不同，聚簇索引对主键查询有很高的性能。不过它的二级索引（secondary index，非主键索引）中必须包含主键列，所以如果主键列很大的话，其他的所有索引都会很大，因此，若表上的索引较多的话，主键应当尽可能的小。InnoDB的存储格式是平台独立的，也就是说可以将数据和索引文件从Intel平台复制到PowerPC或者Sun SPARC平台。

InnoDB内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建hash索引以加速读操作哦的自适应哈希索引（adaptive hash index）以及能够加速插入操作的插入缓冲区（insert buffer）等。

作为事务型的存储引擎，InnoDB通过一些机制和工具支持真正的热备份，oracle提供的Mysql Enterprise Backup 、Percona提供的开源的XtraBackup 都可以做到这一点MySQL的其他存储引擎不支持热备份，要获取一直性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可也意味着停止读取。

### 4.2、MyISAM

**加锁与并发**

MyISAM对整张表加锁，而不是针对行。读取时会对需要读到的所有表加共享锁，写入时则对表加排他锁。但是在表有读取查询的同时，也可以往表中插入新的记录(这被称为并发插入，CONCURRENT INSERT)。

**修复**

对于MyISAM表，MySQL可以手工或者自动执行检查和修复操作，但这里说的修复和事务恢复以及崩溃恢复是不同的概念。执行表的修复可能导致一些数据丢失，而且修复操作是非常慢的，可以通过***CHECK TABLE TABLE_NAME*** 检查表的错误，如果有错误可以通过执行***REPAIR TABLE TABLE_NAME\*** 进行修复。另外，如果MySQL服务器已经关闭，也可以通过命令行工具 ***myisamchk*** 进行检查和修复操操作。

**索引特性**

对于MyISAM表，即使是BLOB和TEXT等长字段，也可以基于前500 个字符创建索引，MyISAM也支持全文索引，这是一种基于分词创建的索引，也可以支持复杂的查询。

**延迟更新索引键（Delayed Key Write）**

创建MyISAM表的时候，如果指定了DWELAY_KEY_WRITE选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区（in-memory key buffer），只有在清理键缓冲区或者关闭表的时候才会将对应的索引快写入磁盘，这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引的损坏，需要执行修复操作，延迟更新索引建的特性，可以在全局设置，也可以在单个表设置。

