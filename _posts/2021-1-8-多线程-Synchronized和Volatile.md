---
title: 多线程学习—Synchronized和Volatile
date: 2021-1-8 23:29:53
categories:
- 多线程
tags:
- 多线程
---

## 1、Synchronized关键字介绍

### 1.1、什么是Synchronized锁

​    synchronized块是Java提供的一种原子性内置锁，Java中的每个对象都可以把它当作一个同步锁来使用，这些Java内置的使用者看不到的锁被称为**内部锁**，内部锁是一种排他锁，它能够保障**原子性、可见性和有序性**。

### 1.2、Synchronized锁的三种应用方式

-  修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁 。
-  修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 。
-  修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 

### 1.3、Synchronized的内存语义

- 进入synchronized块的内存语义是把在synchronized块内存使用到的变量从线程的工作内存中清除。
- 退出synchronized块的内存语义是把在synchronized块内对共享变量的修改刷新到主内存中。

### 1.4、Synchronized的可重入性

​     从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求**自己**持有对象锁的临界资源时，这种情况**属于重入锁**，请求将会成功，在java中synchronized是基于原子性的内部锁机制，是**可重入**的。因此在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是synchronized的可重入性。**子类也可以调用父类的synchronized方法**。

## 2、Volatile关键字介绍

###  2.1、什么是Volatile？

​    volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“**可见性**”。它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。注意volatile并**不保证原子性**。

###  2.2、Volatile如何保障可见性？

   如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条LOCK前缀的指令，将这个变量锁在缓存行的数据写回到系统内存。为了保证各个处理器的缓存是一致的，就会实现**缓存一致性协议**，将自己缓存设为无效状态，当处理器对这个数据进行修改操作时，会重新从系统内存中把数据读到处理器缓存里。

