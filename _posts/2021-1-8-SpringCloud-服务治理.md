---
title: SpringCloud学习-服务治理
date: 2021-1-8 23:29:53
categories:
- Spring
tags:
- Spring
---

## 1、什么是服务治理？

​       服务治理是微服务架构中的最为核心和基础的模块，它**主要用来实现各个微服务实例的自动化注册和发现**。

服务治理都围绕着**服务注册**和**服务发现**机制来完成对微服务应用实例的自动化管理。

- 服务注册：在服务治理框架中，通常都会构建一个注册中心，每个服务单元向注册中心登记自己提供的服务，将主机、端口号 、版本号、通信协议等一些附加信息告知注册中心。服务注册中心还需要以心跳的方式去检测清单中的服务是否可用，若不可用要从清单中剔除。
- 服务发现：由于服务治理框架的运作，服务间的调用不再通过指定具体的实例地址来实现，而是向服务注册中心咨询服务，并获取所有服务的实例清单，以实现对具体服务实例的访问。*注意：仅仅是获取服务实例清单，具体选择哪个服务是Ribbon去负责服务消费。*

### Eureka服务端

​    主要负责服务的注册、发现、状态的维护。

###  Eureka客户端

​     负责向注册中心注册自身体提供的服务并发送心跳来更新状态，同时从服务端查询当前服务的注册信息来周期性的刷新服务状态。负责服务发现，向服务注册中心咨询服务，获取所有服务的实例清单。

### 高可用注册中心

Eureka Server 的高可用实际上就是**将自己作为服务向其他服务注册中心注册自己**，这样就可以形成一组互相注册的服务注册中心，以实现服务清单的互相同步。

## 2、Eureka详解

### 2.1、基础架构

Eureka服务治理基础架构的三个核心要素：

- **服务注册中心**：Eureka提供的服务端，提供服务注册与发现的功能。也就是在上一节中的eureka-server。
- **服务提供者**：提供服务的应用，可以是SpringBoot应用，也可以是其他技术平台且遵循Eureka通信机制的应用。它将自己提供的服务注册到Eureka，以供其他应用发现，也就是上一节中我们实现的HELLO-SERVICE应用。
- **服务消费者**：消费者应用从服务注册中心获取服务列表，从而使消费者可以知道去何处调用其所需要的服务，可以使用Ribbon或Feign等消费方式。

### 2.2、服务提供者

- **服务注册**

​     服务提供者在启动的时候会通过REST请求的方式将自己注册到Eureka Server上，同时带上自身服务的一些元数据信息。Eureka Server接收到这个Rest请求之后，将元数据信息存储在一个双层结构的Map中，其中第一层的key是服务名。第二层的key 是具体服务的实例名。

在服务注册时，需要确认一下eureka.client.register-with-eureka=true参数是否正确，该值默认为true。若设置为fasle将不会启动注册操作。

- **服务同步**

​    从eureka服务治理体系架构图中可以看到，不同的服务提供者可以注册在不同的服务注册中心上，它们的信息被不同的服务注册中心维护。

此时，由于多个服务注册中心互相注册为服务，当服务提供者发送注册请求到一个服务注册中心时，它会将该请求转发给集群中相连的其他注册中心，从而实现服务注册中心之间的服务同步。通过服务同步，提供者的服务信息就可以通过集群中的任意一个服务注册中心获得。

- **服务续约**

   在注册服务之后，服务提供者会维护一个心跳用来持续高速Eureka Server，“我还在持续提供服务”，否则Eureka Server的剔除任务会将该服务实例从服务列表中排除出去。我们称之为服务续约。 

下面使服务续约的两个重要属性：

 （1）eureka.instance.lease-expiration-duration-in-seconds 

 （2）eureka.instance.lease-renewal-interval-in-seconds 

### 2.3、服务消费者

- **获取服务**

 消费者服务启动时，会发送一个Rest请求给服务注册中心，来获取上面注册的服务清单。为了性能考虑，Eureka Server会维护一份只读的服务注册清单来返回给客户端，同时该缓存清单默认会每隔30秒更新一次。 

 下面是获取服务的两个重要的属性： 

​    （1）eureka.client.fetch-registry 

​    （2）eureka.client.registry-fetch-interval-seconds 

- **服务调用**

​      服务消费者在获取服务清单后，通过服务名可以获取具体提供服务的实例名和该实例的元数据信息。因为有这些服务实例的详细信息，所以客户端可以根据自己的需要决定具体调用哪个实例，在Ribbon中会默认采用轮询的方式进行调用，从而实现客户端的负载均衡。 

- **服务下线**

   在系统运行过程中必然会面临关闭或重启服务的某个实例的情况，在服务关闭操作时，会触发一个服务下线的Rest服务请求给Eureka Server，告诉服务注册中心：“我要下线了。”服务端在接收到该请求后，将该服务状态置位下线（DOWN），并把该下线事件传播出去。 

### 2.4、服务注册中心

- **失效剔除**

​     当服务实例因为内存溢出，网络等原因导致服务不能正常工作，但是注册中心却没有收到服务实例的下线请求。为了解决这个问题，Eureka Server在启动的时候会创建一个定时任务，该定时任务的作用是每隔60s，将当前服务列表清单中超过90s没有续约的服务剔除出去。 

- **自我保护机制**

​     Eureka Server 在运行期间会去统计心跳失败比例在 15 分钟之内是否低于 85%，如果低于 85%，Eureka Server 会将这些实例保护起来，让这些实例不会过期，但是在保护期内如果服务刚好这个服务提供者非正常下线了，**此时服务消费者就会拿到一个无效的服务实例，此时会调用失败**，对于这个问题需要服务消费者端要有一些容错机制，如重试，断路器等。此时我们可以使用eureka.server.enable-self-preservation=false来关闭保护机制 。

## 3、常用配置项

![]({{ site.url }}/assets/img/spring/6.1.png)


![]({{ site.url }}/assets/img/spring/6.2.png)

## 4、参考资料

1、 https://blog.csdn.net/java_yes/article/details/80703623 

