---
title: 高性能MySQL学习（4）—schema 与数据类型优化
date: 2021-2-23 23:29:53
categories:
- 数据库
tags:
- 数据库
---

## 1、选择优化的整数类型

Mysql支持的数据类型非常多，选择正确的数据类型对于获得高性能至关重要。在为列选择数据类型时，第一步需要确定合适的大类型，下一步是选择具体类型相同大类型下的不同子类型数据有时也有一些特殊的行为和属性。

　　1.更小的数据类型通常更好

　　2.简单就好

　　3.尽量避免NULL

### 1.1、整数类型

| 整数类型  | 占用空间 | 范围           |
| --------- | -------- | -------------- |
| TINYINT   | 8        | [-2^7,2^7-1]   |
| SMALLINT  | 16       | [-2^15,2^15-1] |
| MEDIUMINT | 24       | [-2^23,2^23-1] |
| INT       | 32       | [-2^31,2^31-1] |
| BIGINT    | 64       | [-2^63,2^63-1] |

可以使用的几种整数类型：**TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT**分别使用8，16，24，32，64位存储空间。

整数类型有可选的UNSIGNED属性，表示**不允许负值**，这大致可以使正数的上限提高一倍。

**整数计算一般使用64位的BIGINT整数**，即使32位环境也是如此（一些聚合函数是例外，他们使用DECIMAL或DOUBLE进行计算）。

### 1.2、**实数类型**

**FLOAT**和**DOUBLE**类型支持使用标准的浮点运算进行近似计算。DECIMAL类型用于存储精确的小数，Mysql服务器自身实现了DECIMAL的高精度计算，相对而言，CPU直接支持原生浮点计算，所以浮点计算明显更快。

浮点和**DECIMAL**类型都可以指定精度，对于DECIMAL可以指定小数点前后所允许的最大位数，这会影响列的空间消耗。

浮点类型在存储同样范围的值时，通常比DECIMAL使用更少的空间，所以应该尽量只在对小数进行精确计算时才使用。

### 1.3、**字符串类型**

VARCHAR和CHAR是两种最主要的字符串类型。

**VARCHAR类型存储可变长字符串**，他比定长类型更节省空间，VARCHAR节省了存储空间，所以对性能也有帮助，但由于是变长的，在UPDATE时可能使行变得比原来长，这就导致需要做额外的工作。

CHAR是定长的，适合存储很短的字符串（末尾会用空格填充）。

### 1.4、**BLOB和TEXT类型**

**blob:**采用二进制的方式存储，没有排序规则和字符集。包含tinyblob,blob,mediumblob,longblob

**TEXT:**采用字符串的方式存储，有排序规则和字符集，包含tinytext,text,mediumtext,longtext。

与其他类型不同，MySQL把每个BLOB值和TEXT值当作一个独立的对象处理，存储引擎在存储时通常会做特殊处理，当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域来存储，在原本的行中使用指针指向外部的存储区域。同事这两种数据格式最多只能建立前缀索引。

### 1.5、**使用枚举（ENUM）代替字符串类型**

有时候可以使用枚举代替常用的字符串类型，枚举把一些不重复的字符串存储成一个预定义的集合。枚举在保存时是（数字-字符串）的形式。

### 1.6、**日期和时间类型**

Mysql使用许多类型保存日期和时间值，例如**year和date**，Mysql能存储的**最小时间粒度为秒**，Mysql提供两种相似的日期类型：DATETIME和TIMESTAMP，在某些场合一个比另一个工作的更好。

**datetime：**1001-9999年，精度是秒，8个字节；
**timestamp：**1970年以来的秒数，4个字节，最大到2038年；

### 1.7、**位数据类型**

**BIT：**最大长度64个位。Mysql把BIT当作字符串类型，而不是数字类型。

**SET：** 一系列打包位的集合。Mysql有像FIND_IN_SET和FIELD这样的函数，方便在查询中使用。他的主要缺点是改变列的代价太高，也无法在SET上通过索引查找。

## 2、mysql schema设计中的陷阱

### 2.1、太多的列

 MySQL的存储引擎API在工作的时需要在服务器层和存储引擎层通过行缓冲格式拷贝数据，然后在服务器层将行缓冲内容解码成各个列。从行缓冲中将编码过的列转换成行结构的操作代价非常的高，转换的代价依赖于列的数量。

### 2.2、太多的关联

 一个粗略的经验法则，如果希望查询执行的快且并发性好，单个查询最好在12个表内做关联

### 2.3、NULL值

 需要存储一个事实上的“空值”到列表中时，可以使用0，某个特殊值，或者空字符串代替。MySQL会在索引中存储NULL值，而Oracle则不会。

## 3、范式和反范式

 在范式化的数据库中，每个事实数据只会出现一次，

 反范式化的数据库中，信息是冗余的，可能会存储在多个地方。

### 3.1范式化的优点和缺点

**优点：**

 范式化的更新操作更快，只需要更改较少的数据。

 范式化的表更小，可以更好的放在内存里，执行操作会更快。

 没有多余的数据，可以减少distinct或GROUP BY的操作。

**缺点：**

 通常需要关联，关联代价昂贵，也可能使一些索引策略无效。

### 3.2 反范式的优点和缺点

**优点:**

 所有的数据都在一张表中，可以避免关联。

 不关联的时候即使全表扫描，也是顺序IO。

**缺点：**

 冗余的多余数据，更新更慢

 表大，放到内存中，占用大，容易挤出热数据

## 4、缓存表和汇总表

**缓存表**：存储那些可以比较简单地从schema其他表获取数据的表（存在逻辑上冗余的数据）；

**汇总表**：保存使用GROUP BY语句聚合数据的表；