---
title: 深入理解计算机系统（4）—处理器体系结构
date: 2021-1-28 23:29:53
categories:
- 操作系统
tags:
- 操作系统
---

## 1、CPU的组成

传统上，CPU由**控制器**和**运算器**这两个主要部件组成。

随着集成电路技术的不断发展和进步，新型CPU纷纷集成了一些原先置于CPU之外的分立功能部件，如**浮点处理器、高速缓存（Cache）**等，在大大提高CPU性能指标的同时，也使得CPU的内部组成日益复杂化。

CPU主要组成部分的逻辑结构如图3-2所示：

![img]({{ site.url }}/assets/img/Linux/4.1.webp)

### **1.1、控制器**

**控制器是整个计算机系统的指挥中心**。在控制器的指挥控制下，运算器、存储器和输入/输出设备等部件协同工作，构成了一台完整的通用计算机。

控制器根据程序预定的指令执行顺序，从主存取出一条指令，按该指令的功能，用硬件产生所需的带有时序标志的一系列微操作控制信号，控制计算机内各功能部件的操作，协调和指挥整个计算机完成指令的功能。

控制器通常由**程序计数器（PC）、指令寄存器（IR）、指令译码器（ID）、时序发生器**和**操作控制器**组成。其主要功能包括：

1. 从主存中取出一条指令，并指出下一条指令在主存中的位置；
2. 对指令进行译码，并产生相应的操作控制信号，以便启动规定的动作；
3. 指挥并控制CPU、主存和输入/输出设备之间数据流动的方向。

### **1.2、运算器**

运算器是计算机中用于实现数据加工处理等功能的部件，**它接受控制器的命令，负责完成对操作数据的加工处理任务，其核心部件是算术逻辑单元(Arithmetic Logic Unit，ALU)**。

相对控制器而言，运算器接受控制器的命令而进行动作，即运算器所进行的全部操作都是由控制器发出的控制信号来指挥的，所以它是执行部件。

运算器由**算术逻辑单元(ALU)、累加寄存器（AC）、数据寄存器（DR）**和**程序状态字寄存器（PSW）**组成。它有两个主要功能：

1. 执行所有的算术运算；
2. 执行所有的逻辑运算，并进行逻辑测试。

### 1.2、寄存器

在CPU中至少要有六类寄存器：指令寄存器（IR）、程序计数器（PC）、地址寄存器（AR）、数据寄存器（DR）、累加寄存器（AC）、程序状态字寄存器（PSW）。

这些寄存器用来暂存一个计算机字，其数目可以根据需要进行扩充。

下面详细介绍这些寄存器的功能与结构。

**1.数据寄存器（DR）**

数据寄存器（Data Register，DR）主要作为**CPU和主存、外设之间信息传输的中转站**，用以弥补CPU和主存、外设之间操作速度上的差异。数据寄存器用来暂时存放由主存储器读出的一条指令或一个数据字；反之，当向主存存入一个数据字时，也暂时将它们存放在数据寄存器中。

数据寄存器的作用是 ：

1、作为CPU和主存、外围设备之间信息传送的中转站；
2、弥补CPU和主存、外围设备之间在操作速度上的差别；
3、在单累加器结构的运算器中，数据寄存器还可兼作操作数寄存器。

**2.指令寄存器（IR）**

指令寄存器（Instruction Register，IR）**用来保存当前正在执行的一条指令**。当执行一条指令时，先把该指令**从主存读取到数据寄存器中，然后再传送至指令寄存器**。

一条指令被划分为**操作码**和**地址码**2个字段。为了执行任何给定的指令，必须对操作码进行测试，以便识别所要求的操作。指令译码器（Instruction Decoder，ID）就是完成这项工作的。

指令译码器对来自指令寄存器的操作码部分进行译码，以产生操作性质的控制电位，并将其送到微操作控制线路上，在时序部件定时信号作用下，产生具体的操作控制信号。

**指令寄存器中操作码字段的输出就是指令译码器的输入。操作码一经译码后，即可向操作控制器发出具体操作的特定信号**。

**3.程序计数器（PC）**

程序计数器（Program Counter，PC）用来指出下一条指令在主存储器中的单元地址。

在程序执行之前，首先必须将程序的首地址，即程序的第一条指令所在的主存单元地址送入PC。因此**PC的内容即是从主存提取的第一条指令的地址**。

当执行指令时，CPU能自动递增PC的内容，使其始终保持将要执行的下一条指令的主存地址，为取下一条指令做好准备。

但是，当遇到转移指令时，下一条指令的地址将由转移指令的地址码字段指定，而不是像通常那样通过顺序递增PC的内容来取得。

因此，程序计数器的结构应当是具有寄存信息和计数两种功能的结构。

**4.地址寄存器（AR）**

地址寄存器（Address Register，AR）用来**保存CPU当前所访问的主存单元的地址**。

由于在主存和CPU之间存在操作速度上的差异，所以必须使用地址寄存器来暂时保存主存的地址信息，直到主存的存取操作完成为止。

当CPU和主存进行信息交换，即CPU向主存存入/取出数据时，或者CPU从主存中读出指令时，都要使用**地址寄存器**和**数据寄存器**。

同样，如果我们把外围设备的设备地址作为像主存的地址单元那样来看待，那么，当CPU和外围设备交换信息时，我们同样要使用地址寄存器和数据寄存器。

**5.累加寄存器（AC）**

累加寄存器通常简称累加器（Accumulator，AC），是一个通用寄存器。

累加器的功能是：**当运算器的算术逻辑单元(ALU)执行算术或逻辑运算时，为ALU提供一个工作区，可以为ALU暂时保存一个操作数或运算结果**。

显然，运算器中至少要有一个累加寄存器。

**6.程序状态字寄存器**

程序状态字（Program Status Word，PSW）用来**表征当前运算的状态及程序的工作方式**。

程序状态字寄存器保存由算术指令和逻辑指令运行或测试的结果所建立起来的各种条件码内容，如运算结果进/借位标志(C)、运算结果溢出标志（O)、运算结果为零标志(Z)、运算结果为负标志(N)、运算结果符号标志（S）等，这些标志位通常分别用1位触发器来保存。

除此之外，程序状态字寄存器还保存中断和系统工作状态等信息，以便CPU和系统及时了解机器运行状态和程序运行状态。

因此，程序状态字寄存器是一个保存各种状态条件标志的寄存器。

## 2、Y86-64指令集体系结构

   我们知道计算机系统底层硬件只识别机器语言，而处理器就是用来执行一系列指令，每条指令执行某个简单的操作。比如两个数相加，汇编指令 ADD 会被编码为一个或多个**字节组成的二进制格式**。

> 　一个处理器支持的指令和指令的字节级编码称为它的**指令集体系结构**（Instruction-Set Architecture,ISA）。

　   而不同的处理器家族，比如Intel IA32、IBM/Freescale PowerPC和AMD处理器家族，都有不同的ISA。这和我们上一章讲的汇编语言是直接面向处理器（Processor）的程序设计语言，不同类型的CPU 有不同的机器指令系统，也就有不同的汇编语言是一样的。不同的处理器，其指令集体系结构也不一样，也就是说一个程序编译成在一种机器上运行，就不能在另外一种机器上运行，如何处理这种兼容性问题呢？**ISA 在编译器编写者和处理器设计人之间提供了一个抽象概念层，编译器编写者只需要知道允许哪些指令，以及它们是如何编码的；而处理器设计者必须建造出这些指令的处理器。** 

###  2.1、Y86指令

　和IA32一样，Y86程序员可见部分包括：**寄存器、存储器、条件码、PC（程序计数器）、程序状态。**

　在Y86当中，寄存器也是有8个，每一个寄存器可以存储一个字，也就是一个32位二进制。条件码是一个一位二进制的寄存器，保存着最近的算术或逻辑运算所造成的影响的信息。PC则是程序计数器，记录当前正在执行的指令的地址。存储器则是一个很大的字节数组，保存着程序和数据，Y86的程序可以使用虚拟地址（类似于数组的下标）来访问存储器，硬件和操作系统会将虚拟地址翻译为实际的地址。最后一个程序状态（stat），它则代表着程序的运行情况。它会指示程序是否正常运行，或者发生了某个特殊事件。

　　下图是 Y86 ISA 各个指令的描述，左边是指令的汇编码表示，右边是字节编码。它只包括四字节整数操作。

![]({{ site.url }}/assets/img/Linux/4.2.png)

​       halt :这个指令会停止指令的执行。在IA32中有个与之相当的指令 hlt，不过IA32的应用程序不允许使用这条指令，因为它会导致整个系统暂停运行。而对于Y86来讲，执行 halt 指令会导致处理器停止，并将状态码设置为 HLT。

　　nop：这是一个占位指令，它不做任何事情，后续为了实现流水线，它有一定的作用。

　　xxmovl：这是一系列的数据传送指令，其中r代表寄存器，m代表存储器，i代表立即数。比如rrmovl指令，则代表将一个寄存器的值，赋给另外一个寄存器。

　　OPl:这包括4个整数操作指令，addl、subl、andl和xorl。他们只对寄存器数据进行操作。

　　jXX:包括7个跳转指令，jmp,jle,jl,je,jne,jge,jg。根据分支指令的类型和条件码的设置来选择分支。

　　cmovXX:包括6个条件传送指令，cmovle,cmovl,cmove,cmovne,cmovge和cmovg，只发生在两个寄存器之间，不会将数据传送到存储器。

　　call:指令将返回地址入栈，然后跳到目的地址。

　　ret:call是过程调用，ret是返回。将返回地址入PC，并跳到返回地址。

　　pushl和popl:指令实现了地址的入栈和出栈

### 2.2、指令编码

​     指令集的一个重要性质就是字节编码**必须要有唯一的解释**。任何一个字节序列要么是一个唯一的指令序列的编码，要么就不是一个合法的字节序列。

　Y86就具有这个性质，因为每条指令的**第一个字节有唯一的代码和功能组合**，给定这个字节，我们就可以决定所有其他附加字节的长度和含义。这个性质保证了处理器可以**无二义性**的执行目标程序代码。即使代码嵌入在程序的其它字节中，只要从序列的第一个字节开始处理，我们仍然可以很容易的确定指令序列。反过来，如果不知道一段代码序列的起始位置，我们就不能准确的确定怎样将序列划分为单独的指令。对于试图直接从目标代码字节序列中抽取出机器级程序的反汇编程序和其它一些工具来说，就带来了困难。

下图是整数操作、条件传送和分支指令的具体编码：

![]({{ site.url }}/assets/img/Linux/4.3.png)

### 2.3、Y86异常

对于Y86来说，程序员可见的状态中包括stat状态码，它标识了程序执行的状态。这个状态码的可能值如下：

　　![img]({{ site.url }}/assets/img/Linux/4.4.png)

　　对于Y86，当程序遇到异常时，我们就简单的让处理器停止执行指令。但是在更完整的设计中，处理器通常会调用一个异常处理程序，这个过程被指定用来处理遇到的某种类型的异常。

## 3、逻辑设计和硬件控制语言HCL

### 3.1、逻辑门

逻辑门是数字电路的基本计算元素，它们产生的输出，等于它们输入位值的某个布尔函数。如下图：

　　![img]({{ site.url }}/assets/img/Linux/4.5.png)

　　这三个逻辑门和我们前面讲C语言运算符是对应的。但是要注意区别：

　　①、逻辑门只对单个位进行操作，而不是整个字。这很好理解，因为硬件识别的是高低电平。

　　②、逻辑门总是活动的，一旦一个门的输入变化了，在很短的时间内，输出就会相应的变化。

### 3.2、字级组合电路和 HCL 整数表达式

前面我们说的高级逻辑设计，也依然是针对1位进行操作的。那么如何才能真正操作多个位呢，比如平时常用的32位或者64位。那么我们就必须将多个位一起操作，比如下面的：

　　![img]({{ site.url }}/assets/img/Linux/4.6.png)

这个图当中每个位相等的判断都是上面所提到的两个not门，两个and门和一个or门组成的组合电路。总共32个，它们并列的一起进行，最终再通过一个and门，就完成了判断两个32位的数字是否相等的操作。也就是表达式A == B，值得注意的是，这里的A和B都是32位的。C语言中可以假设为 int 型的。 

### 3.3、存储器和时钟

​     上面我们介绍的都是组合电路，**它们的作用是根据输入来产生一个值**。但是刚才也说过，**组合电路是一直持续输出的，因此它无法保持一个状态不变**。也就是说**组合电路从本质上来讲，不存储任何信息**。他们只是简单的响应输入信号，产生等于输入的某个函数的输出。但我们的计算机是需要存储数据的，因此就需要能保存状态的存储设备。存储设备是由一个时钟控制，时钟是一个周期型号，它控制着存储设备什么时候更新设备里的值。 

　常用的存储设备一般有两种：

　　①、时钟寄存器：简称寄存器，存储**单个位或字**。时钟信号控制寄存器加载输入值。

　　②、随机访问存储器：简称存储器，**存储多个字**，用地址来选择该读或者该写哪个字。

​      时钟寄存器的典型应用是程序计数器PC、条件码寄存器以及程序状态。

​      随即访问存储器最典型的例子就是我们的寄存器文件（也就是8个程序寄存器）和随即访问存储器（也就是我们常说的内存）。 

## 4、Y86-64的顺序实现

我们初步要实现的处理器是顺序的，即完全执行完一条指令才执行下一条指令。

通常，会将不同的指令分解成相同的阶段序列，这样有利于简化处理器设计及充分利用硬件。

 下面是各阶段的简略描述： 

- **取指（fetch）**：按 PC 保存的地址从存储器读取指令字节，并计算出紧邻的下一条指令的地址 valP。
- **译码（decode）**：从寄存器文件中读入所需的操作数 valA 和\或 valB。
- **执行（execute）**：该阶段计算出的值称为 valE。
- **访存（memory）**：从存储器读出数据 valM，或向存储器写入数据。
- **写回（write back）**：最多可以写两个结果到寄存器文件。
- **更新 PC（PC update）**：将 PC 设置成下一条指令的地址。



