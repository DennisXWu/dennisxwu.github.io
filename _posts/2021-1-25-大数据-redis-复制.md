---
title: Redis学习(10)—复制
date: 2021-1-25 23:29:53
categories:
- 大数据
tags:
- 大数据
---

## 1、旧版复制(Redis2.8之前)

### 1.1、旧版复制的实现

**Redis的复制功能分为下面两个操作：**

- **同步操作**（sync）**：**用于将从服务器的数据库状态**更新至**主服务器当前所处的数据库状态
- **命令传播操作**（command propagate）**：**则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库**重新回到一致状态**

*一、同步（SYNC命令）*

**概念：**当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作，也即是，**将从服务器的数据库状态更新至主服务器当前所处的数据库状态**

**SYNC命令：**从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，以下是SYNC命令的执行步骤：

![img]({{ site.url }}/assets/img/大数据/11.1.webp)

1. 从服务器向主服务器**发送SYNC命令**
2. 收到SYNC命令的主服务器**执行BGSAVE命令，在后台生成一个RDB文件**，并使用一个缓冲区记录从现在开始执行的所有写命令
3. 当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的**RDB文件发送给从服务器**，从服务器**接收并载入**这个RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态
4. 主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态

*二、命令传播*

 在同步操作执行完毕之后，主从服务器两者的数据库将达到一致状态，但这种一致并不是一成不变的，每当主服务器执行客户端发送的写命令时，主服务器的数据库就有可能会被修改，并**导致主从服务器状态不再一致**

![img]({{ site.url }}/assets/img/大数据/11.2.webp)

 为了让主从服务器再次回到一致状态，**主服务器需要对从服务器执行命令传播操作：**主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态

### 1.2、旧版复制的缺陷

在Redis中，**从服务器对主服务器的复制可以分为以下两种情况：**

- **初次复制：**从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务 器和上一次复制的主服务器不同。

- **断线后重复制：**处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务 器通过自动重连接重新连上了主服务器，并继续复制主服务器

  对于初次复制来说，旧版复制功能能够很好地完成任务，但对于断线后重复制来说，旧版复制功能虽然也能让主从服务器重新回到一致状态，**但效率却非常低**

**为什么网络断开之后重新复制效率低？**

- 主从服务器在时间T0至时间T10086中一直处于一致状态，这两个服务器保存的数据**大部分都是相同的**
- 从服务器想要将自己更新至主服务器当前所处的状态，**真正需要的是主从服务器连接中断期间**，主服务器新添加的k10087、k10088、k10089三个键的数据
- 可惜的是，旧版复制功能并没有利用以上列举的两点条件，而是继续让主服务器生成并向从服务器发送包含键k1至键k10089的RDB文件，但实际上RDB文件包含的键k1至键k10086的数据对于从服务器来说都是不必要的。

## 2、新版复制

### 2.1、新版复制的实现

为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis从2.8版本开始，**使用PSYNC命令代替SYNC命令**来执行复制时的同步操作

**PSYNC命令具有完整重同步（full resy nchronization）和部分重同步（partial resynchronization）两种模式：**

- **完整重同步：**用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步
- **部分重同步：**则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器 时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。

PSYNC命令的部分重同步模式**解决了旧版复制功能在处理断线后重复制时出现的低效情况**

## 3、同步的实现细节

**同步功能由以下三个部分构成：**

- 主服务器的复制偏移量（replication offset）和从服务器的复制偏移量
- 主服务器的复制积压缓冲区（replication backlog）
- 服务器的运行ID（run ID）

### 3.1、复制偏移量

执行复制的双方——主服务器和从服务器会

**分别维护一个复制偏移量：**

- 主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N
- 从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N

通过对比主从服务器的复制偏移量，**程序可以很容易地知道主从服务器是否处于一致状态：**

- 如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的
- 相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态

在下图所示的例子中，主从服务器的复制偏移量的值都为10086

![img]({{ site.url }}/assets/img/大数据/11.3.webp)

如果这时主服务器向三个从服务器传播长度为33字节的数据，那么主服务器的复制偏移量将更新为10086+33=10119，而三个从服务器在接收到主服务器传播的数据之后，也会将复制偏移量更新为10119，如下图所示：

![img]({{ site.url }}/assets/img/大数据/11.4.webp)

**网络断开重连后的复制偏移量：**

 考虑以下这个例子：假设如上面的图片所示，主从服务器当前的复制偏移量都为10086，但是就在主服务器要向从服务器传播长度为33字节的数据之前，从**服务器A断线**了，那么主服务 器传播的数据将只有从服务器B和从服务器C能收到，在这之后，主服务器、从服务器B和从 服务器C三个服务器的复制偏移量都将更新为10119，而断线的从服务器A的复制偏移量仍然停留在10086，这说明从服务器A与主服务器并不一致，如下图所示：

![img]({{ site.url }}/assets/img/大数据/11.5.webp)

 假设从服务器A在断线之后就立即重新连接主服务器，并且成功，那么接下来，从服务器将向主服务器发送PSYNC命令，报告从服务器A当前的复制偏移量为10086，那么这时， **主服务器应该对从服务器执行完整重同步还是部分重同步呢？**如果执行部分重同步的话，主 服务器又如何补偿从服务器A在断线期间丢失的那部分数据呢？**以上问题的答案都和复制积压缓冲区有关**

### 3.2、复制积压缓冲区

复制积压缓冲区是由主服务器维护的一个**固定长度（fixed-size）先进先出（FIFO）队列**，默认大小为1MB

当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会**将写命令入队到复制积压缓冲区里面**，如下图所示：

![img]({{ site.url }}/assets/img/大数据/11.6.webp)

因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会**为队列中的每个字节记录相应的复制偏移量**，就像下表展示的那样

![img]({{ site.url }}/assets/img/大数据/11.7.webp)

当从服务器重新连上主服务器时，从服务器会通过PSYNC命令**将自己的复制偏移量offset发送给主服务器**，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操 作：

- 如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）**仍然存在于复制积压缓冲区里面**，那么主服务器将对从服务器执行**部分重同步**操作
- 相反，如果offset偏移量之后的数据**已经不存在于复制积压缓冲区**，那么主服务器将对从服务器执行**完整重同步**操作

### 3.3、服务器运行ID

除了复制偏移量和复制积压缓冲区之外，

**实现部分重同步还需要用到服务器运行ID（run ID）：**

- 每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID
- 运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成，例如 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3

当从服务器对主服务器**进行初次复制时**，主服务器会**将自己的运行ID传送给从服务器**， 而从服务器则会将**这个运行ID保存起来**

当从服务器断线并重新连上一个主服务器时，**从服务器将向当前连接的主服务器发送之前保存的运行ID：**

- 如果从服务器保存的运行ID和当前连接的主服务器的**运行ID相同**，那么说明从服务器 断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操 作
- 相反地，如果从服务器保存的运行ID和当前连接的主服务器的**运行ID并不相同**，那么 说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服 务器执行完整重同步操作

### 3.4、PSYNC命令的实现

**PSYNC命令的调用方法有两种：**

如果从服务器**以前没有复制过任何主服务器，或者之前执行过SLAVEOF no one命令：**那么从服务器在开始一次新的复制时将向主服务器发送PSYNC ? -1命令，主动请求主服务器**进行完整重同步**（因为这时不可能执行部分重同步）

如果从服务器**已经复制过某个主服务器**，那么从服务器在开始一次新的复制时将向主服务器发送PSYNC <runid> <offset>命令：

- 其中runid是上一次复制的主服务器的运行 ID，而offset则是从服务器当前的复制偏移量
- 接收到这个命令的主服务器会**通过这两个参数来判断应该对从服务器执行哪种同步操作**

**接收到PSYNC命令的主服务器会向从服务器返回以下三种回复的其中一种：**

- 如果**主服务器返回+FULLRESYNC  回复**，那么**表示主服务器将与从服务器执行完整重同步操作：**其中runid是这个主服务器的运行ID，从服务器会将这个ID保存起 来，在下一次发送PSYNC命令时使用；而offset则是主服务器当前的复制偏移量，从服务器 会将这个值作为自己的初始化偏移量
- 如果**主服务器返回+CONTINUE回复**，那么表示**主服务器将与从服务器执行部分重同步操作**，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了
- 如果**主服务器返回-ERR回复**，那么表示主服务器的版本低于Redis 2.8，**它识别不了PSYNC命令**，从服务器将向主服务器发送SYNC命令，并与主服务器执行完整同步操作

## 4、心跳检测

在命令传播阶段，从服务器默认会**以每秒一次的频率**，向主服务器发送命令：

```bash
REPLCONF ACK 

//其中replication_offset是从服务器当前的复制偏移量
```

**发送REPLCONF ACK命令对于主从服务器有三个作用：**

①检测主从服务器的网络连接状态

②辅助实现min-slaves选项

③检测命令丢失

主从服务器可以通过发送和接收REPLCONF ACK命令**来检查两者之间的网络连接是否正常：**如果主服务器**超过一秒钟没有收到**从服务器发来的REPLCONF ACK命令，那么主服务器就知道主从服务器之间的连接出现问题了

 通过向主服务器发送**INFO replication命令**，在列出的**从服务器列表的lag一栏中**，我们可以看到相应从服务器最后一次向主服务器发送REPLCONF ACK命令**距离现在过了多少秒：**

 在一般情况下，**lag的值应该在0秒或者1秒之间跳动**，如果超过1秒的话，那么说明主从 服务器之间的连接出现了故障。