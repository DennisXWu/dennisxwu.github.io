---
title: 算法学习-散列表
date: 2021-1-8 23:29:53
categories:
- 数据结构和算法
tags:
- 数据结构和算法
---

## 1、什么是散列表（哈希表）？

​     散列表也叫hash表 ，是**根据关键码值而进行直接进行访问的数据结构**。也就是说，它通过把**关键码值映射到表中一个位置来访问记录**，以加快查找的速度。这个映射也叫散列函数，存放记录的**数组**叫散列表。

给定表M，存在函数f(key),对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则成表M为Hash表，函数f(key)为**哈希函数**。

对于散列函数，实现的基本要求可以归纳为3点：

1. 散列函数计算得到的散列值是一个非负整数；   
2. 如果 key1 = key2，那 hash(key1) == hash(key2) ；      
3. 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key1) ；（无法避免，会产生散列冲突）  

![]({{ site.url }}/assets/img/算法/8。1.png)


## 2、散列表的常见应用

散列表适用于：

- 模拟映射关系
- 防止重复
- 缓存/记住数据，以免服务器再通过处理来生成它们

## 3、散列表的性能

### 3.1、冲突

给两个键分配相同的位置，叫做**冲突**。

解决冲突的办法有两种：开放寻址法和链表法

### 3.2、开放寻址法

**线性探测法（Linear Probing）**：
1）**插入数据**：当我们往散列表中插入数据时，如果某个数据经过散列函数之后，存储的位置已经被占用了，我们就从当前位置开始，依次往后查找（到底后从头开始），看是否有空闲位置，直到找到为止。

![]({{ site.url }}/assets/img/算法/8.2.png)


2）**查找数据**：我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素是否相等，若相等，则说明就是我们要查找的元素；否则，就顺序往后依次查找。如果遍历到数组的空闲位置还未找到，就说明要查找的元素并没有在散列表中。

当然这里存在一个问题，就是存数据那块位置往前的某个数据被删除了，那么线性探索查到那块位置的时候就会判断元素不在散列表，查找就会失效，面对这个问题，我们在删除的时候，用下面删除的方法

![]({{ site.url }}/assets/img/算法/8.3.png)


![]({{ site.url }}/assets/img/算法/8.4.png)


3）**删除数据**：为了不让查找算法失效，可以将删除的元素特殊标记为deleted，当线性探测查找的时候，遇到标记为deleted的空间，并不是停下来，而是继续往下探测。

![]({{ site.url }}/assets/img/算法/8.5.png)


**二次探测（Quadratic probing）**：线性探测每次探测的步长为1，即在数组中一个一个探测，而二次探测的步长变为原来的平方。

**双重散列（Double hashing）**：使用一组散列函数，直到找到空闲位置为止。

线性探测法的性能描述：
用“装载因子”来表示空位多少，公式：散列表装载因子=填入表中的个数/散列表的长度。
装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。

### 3.3、链表法

散列表中，每个“桶（bucket）”都会对应一个条链表，在查找时先听过hash(key)找到位置，然后遍历链表找到对应元素

插入数据：当插入的时候，我们需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表中即可，所以插入的时间复杂度为O(1)。
查找或删除数据：当查找、删除一个元素时，通过散列函数计算对应的槽，然后遍历链表查找或删除。对于散列比较均匀的散列函数，链表的节点个数k=n/m，其中n表示散列表中数据的个数，m表示散列表中槽的个数，所以是时间复杂度为O(k)。


![]({{ site.url }}/assets/img/算法/8.6.png)


### 3.4、两种方法比较

![](https://upload-images.jianshu.io/upload_images/17483701-235d9f0b4c83fd94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


