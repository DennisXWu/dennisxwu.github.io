---
title: 多线程学习—线程安全
date: 2021-1-8 23:29:53
categories:
- 多线程
tags:
- 多线程
---

## 1、什么是Java内存模型？

​     Java内存模型规定，将所有的变量都存放在主内存中，当线程使用变量时，会把主内存里面的变量复制到自己的工作内存空间或者叫做工作内存，线程读写变量时操作的是**自己工作内存**中的变量。

![]({{ site.url }}/assets/img/多线程/11.1.png)


1.  Java所有变量都存储在主内存中 。
2.  每个线程都有自己独立的工作内存，里面保存该线程的使用到的变量副本（该副本就是主内存中该变量的一份拷贝） 。
3.  线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接在主内存中读写 。
4.  不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。 

## 2、可见性

### 2.1、什么是线程可见性？

​    **线程安全问题**是指当多个线程同时读写一个共享资源并且没有任何同步措施时，导致出现脏数据或者其他不可预见的结果的问题。

假如线程A和线程B同时处理一个共享变量，会出现什么情况？

- 线程A首先获取共享变量X的值，由于工作内存为空，所以加载主内存中的X的值，假如为0。然后把X=0的值刷新到工作内存中，线程A修改X的值为1，然后将其写入工作内存，并刷新到主内存中。
- 线程B获取X的值，由于工作内存为空，所以加载主内存中的X的值，X=1。然后线程B修改X的值为2，并将其刷新到工作内存，最后更新到主内存中。
- 线程A这次又需要修改X的值，获取工作内存中的值，X=1。这里问题就出现了，明明线程B已经把X的值修改为2了，为何线程A获取的还是1呢？**这就是共享变量的内存不可见问题，也就是线程B写入的值对线程A不可见**。

内存可见性例子如下所示：

```java
public class TestMemoryBarrier {
    boolean running = false;

    boolean get() {
        return running;
    }

    void doSetTrue() {
        running = true;
    }

    public static void main(String[] args) throws InterruptedException {
        TestMemoryBarrier instance = new TestMemoryBarrier();

        new Thread(
            () -> {
                while (!instance.get()) {
                }

                System.out.println("Thread 1 finished.");
            }).start();

        Thread.sleep(100);

        new Thread(
            () -> {
                instance.doSetTrue();
                System.out.println("Thread 2 finished.");
            }).start();
    }
}
```

 因为无法获知线程2对共享变量`running`做出的修改, 然后线程1一直处在运行状态。 

### 2.2、如何解决可见性问题？

线程A对共享变量的修改，如果要被线程B及时看到，必须经过如下2个过程

1.  线程修改后的共享变量值能够及时从工作内存中刷新到主内存中 。
2.  其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中 。

## 3、原子性

   原子的字面意思是**不可分割**的。其含义是指访问某个共享变量的操作从其执行线程以外的任何线程来看，该操作要么已经执行结束要么尚未发生，即其他线程不会“看到”该操作执行了部分的中间效果。

   举个例子，我们进行两次i++操作，我们期望的结果是3，但是有可能结果是2。原因可能是多个线程同时从各自的缓存中读取变量i，分别进行加1操作，然后分别写入系统内存中。那么，想要保证读改写共享变量的操作是原子的，就必须保证ThreadA读改写共享变量的时候，ThreadB不能操作缓存了该共享变量内存地址的缓存。

   ![]({{ site.url }}/assets/img/多线程/11.2.png)


 Java有两种方式来实现原子性：
- **锁**：锁具有排他性，即它能够保障一个共享变量在任意时刻只能被一个线程访问。这就排除了多个线程在同一时刻访问同一个共享变量而导致干扰与冲突的可能，即消除了竞态。
- **CAS指令**：CAS指令实现原子性的方式与锁实现原子性的方式实质上是相同的，差别在于锁通常是在软件这一层次实现的，而CAS是直接在硬件这一层次实现的，它可以被看作“硬件锁”。

## 4、有序性

   **有序性**指在什么情况下一个处理器上运行的一个线程所执行的内存访问操作在另外一个处理器上运行的其他线程看来是乱序的。所谓**乱序**，是指内存访问操作的顺序看起来像是发生了变化。

### 4.1、重排序

​     顺序结构是结构化编程中的一种基本结构，它表示我们希望某个操作必须先于另外一个操作得以执行。但是在多核处理器的环境下，这种操作执行顺序可能是没有保障的，编译器可能改变两个操作的先后顺序。处理器可能不是完全依照程序的目标代码所指定的顺序执行指令。另外，一个处理器上执行的多个操作，从其它处理器的角度来看其顺序可能与目标代码所指定的顺序不一致。这种现象就叫做**重排序**。

​    重排序是对内存访问有关的操作（读和写）所作的一种优化，它可以在不影响单线程程序正确性的情况下提升程序的性能。但是，它可能对多线程程序的正确性产生影响，即它可能导致**线程安全**问题。我们先定义几个与内存操作顺序有关的术语:

- 源代码顺序：源代码中所指定的内存访问操作顺序。
- 程序顺序：在给定处理器上运行的目标代码所指定的内存访问操作顺序。
- 执行顺序：内存访问操作在给定处理器上实际执行的顺序。
- 感知顺序：给定处理器所感知到的该处理器及其它处理器的内存访问操作发生的顺序。

在此基础上，我们将重排序划分为指令重排序和存储子系统重排序两种。

![]({{ site.url }}/assets/img/多线程/11.3.png)


## 5、上下文切换

​    在线程切入和切出那一刻相应的线程所执行的任务进行到什么程度了，这个进度信息就被称为**上下文**。它一般包括通用寄存器的内容和程序计数器的内容。

- **自发性上下文切换**：

1. Thread.sleep()
2. Object.wait()
3. Thread.yield()
4. Thread.join()
5. LockSupport.park()
6. 线程发起I/O操作或者等待其他线程持有的锁。

- **非自发性上下文切换**

1. 时间片用完
2. 有一个比被切除线程优先级更高的线程需要被运行。
3. Java虚拟机垃圾回收也可能导致非自发性上下文切换。

## 6、参考文献

1、《Java并发编程之美》

2、《Java多线程编程实战指南 核心篇》



