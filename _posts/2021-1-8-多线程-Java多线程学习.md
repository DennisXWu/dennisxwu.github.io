---
title: 多线程学习—Java多线程学习
date: 2021-1-8 23:29:53
categories:
- 多线程
tags:
- 多线程
---

## 1、进程和线程

​    **进程**是程序向操作系统申请资源的基本单位，**线程**是进程中可独立执行的最小单位。一个进程可以包含多个线程，同一个进程中的所有线程共享该进程中的资源，如内存空间、文件句柄等。线程所要完成的计算就被称为**任务**。

## 2、线程的生命周期

###  2.1、传统线程模型的5种状态

​    在线程的生命周期中，它要经过**新建**(New)、**就绪**（Runnable）、**运行**（Running）、**阻塞**(Blocked)和**死亡**(Dead)**5种状态**。尤其是当线程启动以后，它不可能一直"霸占"着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换

1.  新建状态，当程序使用**new关键字**创建了一个线程之后，该线程就处于新建状态，此时仅由JVM为其分配内存，并初始化其成员变量的值。

2. 就绪状态，当线程对象调用了**start()方法**之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。

3. 运行状态，如果处于就绪状态的线程获得了CPU，开始执行**run()方法**的线程执行体，则该线程处于运行状态。

4. 阻塞状态，当处于运行状态的线程**失去所占用资源**之后，便进入阻塞状态。

   ![]({{ site.url }}/assets/img/多线程/12.1.png)


### 2.2、线程的六种状态

   其实就是将阻塞状态拆解为：WAITING、TIME_WAITING、BLOCKED

|   状态定义    |  状态名   | 解释                                                         |
| :-----------: | :-------: | ------------------------------------------------------------ |
|     `NEW`     |   初始    | 构造一个线程实例后、启动前，线程处于该状态（任何方式创建都是如此，[点击可查看线程创建方法](https://learn.blog.csdn.net/article/details/99677074)） |
|   RUNNABLE    | 就绪/运行 | 该状态包含了经典线程模型的两种状态：就绪(Ready)、运行(Running)：<br/>-------------------<br/>就绪状态表示有资格运行，但如果一直没拿到时间片，就一直是就绪状态<br/>* 初始状态的线程，start()方法被调用后，就进入RUNNABLE状态，表示就绪(Ready)；并开始等待CPU时间片；<br/>* 等待或阻塞状态结束，如sleep()结束、或其他线程join()结束、拿到锁，也会进入就绪状态<br/>* 线程时间片用完，线程的yield()方法会被调用，线程随即进入就绪状态<br/>-------------------<br/>当线程调度选中该线程、并分配了CPU时间片后，该线程尽管处于Runnable状态，但实际上是运行(Running)；<br/>* 这是线程进入运行状态的唯一方式<br/> |
|    BLOCKED    |   阻塞    | 通常与锁有关系，表示线程正在获取有锁控制的资源，比如进入synchronized代码块，获取ReentryLock等 |
|    WAITING    |   等待    | 进入该状态的线程，等待被显式唤醒（其他线程发出通知或中断，如`notify/notifyAll`, 或者另外的线程终止如`join`的情况），否则处于无限期等待 |
| TIMED_WAITING | 超时等待  | 该状态不同于WAITING，它可以在指定的时间后自动唤醒；<br/>* 处于这种状态的线程不会被分配CPU执行时间；<br/>* `Thread.sleep()`执行后，线程就会进入该状态 |
|  TERMINATED   |   终止    | 表示该线程已经执行完毕；<br/>* 线程Run方法体结束、或主线程（守护线程）的`main()`方法完成时，线程就认为终止了；<br/>* 线程对象可能还存活，但不再是单独执行的线程<br/>* 终止的线程不允许再调用`Thread.start()`方法 |

## 3、如何创建线程

   1、定义Thread类的子类，在该子类中覆盖run方法并在该方法中实现线程任务处理逻辑

   2、创建一个java.lang.Runnable接口的实例，并在该实例的run方法中实现任务处理逻辑，然后以该Runnable接口实例作为构造器的参数直接创建一个Thread的实例。

## 4、参考资料
1、https://www.cnblogs.com/sunddenly/p/4106562.html


