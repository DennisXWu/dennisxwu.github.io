---
title: 深入理解计算机系统（6）—存储器层次结构
date: 2021-1-31 23:29:53
categories:
- 操作系统
tags:
- 操作系统
---

## 1、存储技术

**（一）随机访问存储器**

 随机访问寄存器（RAM）分为**静态**随机访问寄存器（SRAM）和**动态**随机访问寄存器（DRAM）。静态RAM可以作为**高速缓存寄存器**，动态RAM可以用作**主存以及图形系统的帧缓冲区**。静态RAM将每一个位存储在一个双稳态的存储器单元里，构成静态RAM的电路可以无限期的保持在两个不同的电压配置或状态之一。动态RAM将每一个位存储为对电容的充电，所以动态RAM要比静态RAM对干扰的敏感度更高。构成动态RAM的电路被干扰后就不会恢复了。

| 指标     | DRAM  | SRAM     |
| -------- | ----- | -------- |
| 读时间   | <10ns | <4ns     |
| 写时间   | <10ns | <4ns     |
| 耐久性   | 1015  | 1016     |
| 存储密度 | 高    | 低       |
| 单元大小 | 6~8F2 | 5-~120F2 |
| 编程能耗 | 中等  | 低       |

**（二）磁盘存储**

磁盘是用来保存大量数据的存储设备，能比基于RAM的存储器存更多的数据，但是读取数据的速度却远远低于基于RAM的存储器。

**（三）固态硬盘**

固态硬盘（SSD）是一种基于闪存的存储技术。一个SSD包由一个或多个闪存芯片和闪存翻译层组成，闪存芯片替代传统旋转磁盘中的机械驱动器，而闪存翻译是一个硬件/固件设备，扮演与磁盘控制器相同的角色，将对逻辑块的请求翻译成对底层物理设备的访问。

## 2、局部性

局部性是指：一个编写良好的计算机程序倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。
局部性通常有时间局部性和空间局部性。
在一个具有良好**时间局部性**的程序中，被引用过一次的存储器位置可能在不远的将来再被多次引用。
在一个具有良好**空间局部性**的程序中，如果一个存储器位置被引用了一次，那么程序很可能在不远的将来引用附近的一个存储器位置。

## 3、存储器层次

硬件和软件的这些基本属性互相补充得很完美。它们这种相互补充的性质使人想到一种组织存储器系统的方法，称为**存储器层次结构**（ memory hierarchy），下图展示了一个典型的存储器层次结构。一般而言，**从高层往底层走，存储设备变得更慢、更便宜和更大**。在最高层（L0），是少量快速的CPU寄存器，CPU可以在一个时钟周期内访问它们。接下来是一个或多个小型到中型的基于SRAM的高速缓存存储器，可以在几个CPU时钟周期内访问它们。然后是一个大的基于DRAM的主存，可以在几十到几百个时钟周期内访问它们。接下来是慢速但是容量很大的本地磁盘。最后，有些系统甚至包括了一层附加的远程服务器上的磁盘，要通过网络来访问它们。

![]({{ site.url }}/assets/img/Linux/6.1.webp)

- **存储器结构中的缓存**

一般而言，高速缓存（ cache，读作“cash”）是一个小而快速的存储设备，它作为存储在更大、也更慢的设备中的数据对象的缓冲区域。使用高速缓存的过程称为缓存（ caching，读作“ cashing”）。

存储器层次结构的中心思想是，对于每个k，位于k层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存。换句话说，层次结构中的每一层都缓存来自较低一层的数据对象。

数据总是以块大小为传送单元（ transfer unit）在第k层和第k+1层之间来回复制的。虽然在层次结构中任何一对相邻的层次之间块大小是固定的，但是其他的层次对之间可以有不同的块大小。如上图所示，L1和L0之间的传送通常使用的是**1个字**大小的块。L2和L1之间（以及L3和I2之间、I4和I3之间）的传送通常使用的是**几十个字节**的块。而L5和L4之间的传送用的是大小为**几百或几千字节**的块。一般而言，层次结构中较低层（离CPU较远）的设备的访问时间较长，因此为了补偿这些较长的访问时间，倾向于使用较大的块。

- **缓存命中**

当程序需要第k+1层的某个数据对象d时，它首先在当前存储在第k层的一个块中查找d。如果d刚好缓存在第k层中，那么就是我们所说的缓存命中（ cache hit）。

- **缓存不命中**

另一方面，如果第k层中没有缓存数据对象d，那么就是我们所说的缓存不命中（ cache miss）。当发生缓存不命中时，第k层的缓存从第k+1层缓存中取出包含d的那个块，如果第k层的缓存已经满了，可能就会覆盖现存的一个块。（缓存的替换策略：随机替换替换策略，最少被使用（LRU）替换策略）。

- **缓存不命中种类**

区分不同种类的缓存不命中有时候是很有帮助的。如果第k层的缓存是空的，那么对任何数据对象的访问都会不命中。一个空的缓存有时被称为冷缓存（ cold cache），此类不命中称为强制性不命中（ compulsory miss）或冷不命中（ cold miss）。冷不命中很重要，因为它们通常是短暂的事件，不会在反复访问存储器使得缓存暖身（ warmed up）之后的稳定状态中出现。

- **缓存管理**

存储器层次结构的本质是**，每一层存储设备都是较低一层的缓存**。在每一层上，某种形式的逻辑必须管理缓存。这里，我们的意思是指某个东西要将缓存划分成块，在不同的层之间传送块，判定是命中还是不命中，并处理它们。管理缓存的逻辑可以是硬件、软件，或是两者的结合。

## 4、高速缓存存储器

高速缓存关于读的操作非常简单。首先，在高速缓存中查找所需字w*w*的副本。**如果命中**，立即返回字w*w*给CPU。**如果不命中**，从存储器层次结构中较低层中取出包含字w*w*的块，将这个块存储到某个高速缓存行中（可能会驱逐一个有效的行），然后返回字w*w*。

写的情况就要复杂一些了。假设我们要写一个已经缓存了的字w*w***（写命中， write hit）**。在高速缓存更新了它的w*w*的副本之后，怎么更新w*w*在层次结构中紧接着低一层中的副本呢？最简单的方法，称为**直写（ write-through）**，就是立即将w*w*的高速缓存块写回到紧接着的**低一层中**。虽然简单，但是直写的缺点是每次写都会引起**总线流量**。另一种方法，称为**写回（ write-back）**，尽可能地推迟更新，只有当替换算法要驱逐这个更新过的块时，才把它写到紧接着的低一层中。由于局部性，**写回能显著地减少总线流量**，但是它的缺点是**增加了复杂性**。高速缓存必须为每个高速缓存行维护一个额外的修改位（ dirty bit），表明这个高速缓存块是否被修改过。

另一个问题是如何处理写不命中。一种方法，称为**写分配（ write-allocate）**，加载相应的低一层中的块到高速缓存中，然后更新这个高速缓存块。写分配试图利用写的空间局部性，但是缺点是每次不命中都会导致一个块从低一层传送到高速缓存。另一种方法，称为**非写分配（not- write-allocate）**，避开高速缓存，直接把这个字写到低一层中。直写高速缓存通常是非写分配的。写回高速缓存通常是写分配的。

高速缓存既保存数据，也保存指令。只保存指令的高速缓存称为 **i-cache**。只保存程序数据的高速缓存称为 **d-cache**。既保存指令又包括数据的高速缓存称为统一的**高速缓存（ unified cache）**。现代处理器包括独立的 i-cache和d-cache。**这样做有很多原因**。有两个独立的高速缓存，处理器能够**同时读一个指令字和一个数据字**。 i-cache通常是只读的，因此比较简单。通常会针对不同的访问模式来优化这两个高速缓存，它们可以有不同的块大小，相联度和容量。使用不同的高速缓存也确保了数据访问不会与指令访问形成冲突不命中，反过来也是一样，代价就是可能会引起容量不命中增加。